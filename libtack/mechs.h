/*
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT IT.
 * This file corresponds to Version 1.7 of the STSA literate
 * program.
 */
/*
 * This software is copyrighted 2007 - 2014 by G. Andrew
 * Mangogna.  The following terms apply to all files associated
 * with the software unless explicitly disclaimed in individual
 * files.
 *
 * The authors hereby grant permission to use, copy, modify,
 * distribute, and license this software and its documentation
 * for any purpose, provided that existing copyright notices
 * are retained in all copies and that this notice is included
 * verbatim in any distributions. No written agreement, license,
 * or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their
 * authors and need not follow the licensing terms described here,
 * provided that the new terms are clearly indicated on the first
 * page of each file where they apply.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE
 * TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR
 * CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE,
 * ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF, EVEN IF THE
 * AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * AND NON-INFRINGEMENT.  THIS SOFTWARE IS PROVIDED ON AN "AS IS"
 * BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO OBLIGATION
 * TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
 * OR MODIFICATIONS.
 *
 * GOVERNMENT USE: If you are acquiring this software on behalf of
 * the U.S. government, the Government shall have only "Restricted
 * Rights" in the software and related documentation as defined in
 * the Federal Acquisition Regulations (FARs) in Clause 52.227.19
 * (c) (2).  If you are acquiring the software on behalf of the
 * Department of Defense, the software shall be classified as
 * "Commercial Computer Software" and the Government shall have
 * only "Restricted Rights" as defined in Clause 252.227-7013 (c)
 * (1) of DFARs.  Notwithstanding the foregoing, the authors
 * grant the U.S. Government and others acting in its behalf
 * permission to use and distribute the software in accordance
 * with the terms specified in this license.
*/
/*
 * If the symbol MECH_SM_TRACE is defined to the preprocessor,
 * then code supporting state machine dispatch tracing is 
 * included in the object file.
 * If the symbol MECH_NINCL_STDIO is defined to the preprocessor,
 * then code supporting printing of fatal error messages will be
 * removed from the object file.
 * If the symbol MECH_TEST is defined to the preprocessor,
 * then code supporting testing the mechanisms will be
 * included in the object file.
 */
#ifndef MECHS_H_
#define MECHS_H_
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#define MECH_STATECODE_IG UINT8_MAX
#define MECH_STATECODE_CH (UINT8_MAX - 1)
#ifndef MECH_ECB_PARAM_SIZE
#   define MECH_ECB_PARAM_SIZE  16
#endif /* MECH_ECB_PARAM_SIZE */
#ifndef MECH_EVENTPOOLSIZE
#   define MECH_EVENTPOOLSIZE 10
#endif /* MECH_EVENTPOOLSIZE */
#define MECH_DISPATCH_CREATION_STATE    0
#ifndef MECH_SYNCQUEUESIZE
#   define MECH_SYNCQUEUESIZE 10
#endif /* MECH_SYNCQUEUESIZE */
typedef uint8_t AllocCount ;
typedef uint8_t StateCode ;
typedef enum {
    NormalEvent,
    PolymorphicEvent,
    CreationEvent
} MechEventType ;
typedef uint8_t RefCount ;
typedef uint8_t EventCode ;
typedef unsigned long int MechDelayTime ;
typedef uint8_t DispatchCount ;
typedef void ActionFunction(void *const, void *const) ;
typedef ActionFunction *PtrActionFunction ;
typedef enum {
    PolyReference,
    PolyUnion
} PolyStorageType ;
typedef uint8_t SubtypeCode ;
typedef unsigned short int AttributeOffset ;
typedef enum {
    mechCantHappen = 1,
    mechEventInFlight,
    mechNoECB,
    mechNoInstSlot,
    mechSyncOverflow,
    #ifdef __unix__
    mechTimerOpFailed,
    mechSignalOpFailed,
    mechSelectWaitFailed,
    #endif /* __unix__ */
} MechErrorCode ;
typedef struct mechinstance {
    AllocCount alloc ;
    StateCode currentState ;
    struct mechclass const *instClass ;
} *MechInstance ;
typedef void (*InstCtor)(MechInstance) ;
typedef void (*InstDtor)(MechInstance) ;
typedef struct installocblock {
    void *storageStart ;
    void *storageFinish ;
    void *storageLast ;
    AllocCount allocCounter ;
    size_t instanceSize ;
    InstCtor construct ;
    InstDtor destruct ;
} *InstAllocBlock ;
typedef union {
    signed char cparm[MECH_ECB_PARAM_SIZE] ;
    unsigned char ucparm[MECH_ECB_PARAM_SIZE] ;
    unsigned short usparm[MECH_ECB_PARAM_SIZE / sizeof(unsigned short)] ;
    signed short isparm[MECH_ECB_PARAM_SIZE / sizeof(signed short)] ;
    unsigned uparm[MECH_ECB_PARAM_SIZE / sizeof(unsigned)] ;
    int iparm[MECH_ECB_PARAM_SIZE / sizeof(unsigned)] ;
    unsigned long ulparm[MECH_ECB_PARAM_SIZE / sizeof(unsigned long)] ;
    signed long ilparm[MECH_ECB_PARAM_SIZE / sizeof(signed long)] ;
    void *pparm[MECH_ECB_PARAM_SIZE / sizeof(void *)] ;
} EventParamType ;
typedef struct objectdispatchblock {
    DispatchCount stateCount ;
    DispatchCount eventCount ;
    StateCode const *transitionTable ;
    PtrActionFunction const *actionTable ;
    bool const *finalStates ;
} const *ObjectDispatchBlock ;
typedef struct hierarchydispatch {
    PolyStorageType refStorage ;
    AttributeOffset subCodeOffset ;
    AttributeOffset subInstOffset ;
    DispatchCount subtypeCount ;
    struct polyeventmap const *eventMap ;
} const *HierarchyDispatch ;
typedef struct polyeventmap {
    EventCode event ;
    MechEventType eventType ;
} const *PolyEventMap ;

typedef struct polydispatchblock {
    DispatchCount eventCount ;
    DispatchCount hierCount ;
    HierarchyDispatch hierarchy ;
} const *PolyDispatchBlock ;
typedef struct mechclass {
    InstAllocBlock iab ;
    ObjectDispatchBlock odb ;
    PolyDispatchBlock pdb ;
} const *MechClass ;
typedef void (*MechFatalErrHandler)(MechErrorCode, char const *, va_list) ;
typedef EventParamType SyncParamType ;
typedef SyncParamType *SyncParamRef ;
typedef void (*SyncFunc)(SyncParamRef) ;
typedef void (*FDServiceFunc)(int) ;
typedef struct mechecb {
    struct mechecb *next ;
    struct mechecb *prev ;
    RefCount referenceCount ;
    EventCode eventNumber ;
    AllocCount alloc ;
    MechEventType eventType ;
    union {
        MechInstance targetInst ;
        MechClass targetClass ;
    } instOrClass ;
    MechInstance srcInst ;
    MechDelayTime delay ;
    EventParamType eventParameters ;
} *MechEcb ;
extern MechInstance mechInstCreate(
    MechClass instClass,
    StateCode initialState) ;
extern void mechInstDestroy(
    MechInstance inst) ;
extern MechEcb mechEventNew(
    EventCode event,
    MechInstance targetInst,
    MechInstance srcInst) ;
extern MechEcb
mechPolyEventNew(
    EventCode event,
    MechInstance targetInst,
    MechInstance srcInst) ;
extern MechEcb
mechCreationEventNew(
    EventCode event,
    MechClass targetClass,
    MechInstance srcInst) ;
extern void mechEventPost(MechEcb ecb) ;
extern void mechEventPostSelf(MechEcb ecb) ;
extern void
mechEventPostDelay(
    MechEcb ecb,
    MechDelayTime time) ;
extern void
mechEventDelayCancel(
    EventCode event,
    MechInstance targetInst,
    MechInstance srcInst) ;
extern MechDelayTime
mechEventDelayRemaining(
    EventCode event,
    MechInstance targetInst,
    MechInstance srcInst) ;
/*
 * Must be invoked from interrupt service level only!
 */
extern MechDelayTime mechTimerExpireService(void) ;
extern MechFatalErrHandler
        mechSetFatalErrHandler(MechFatalErrHandler) ;
extern bool mechEventAvail(void) ;
extern bool
mechInstAvail(
    MechClass instClass) ;
extern SyncParamRef mechSyncRequest(SyncFunc) ;
extern SyncParamRef mechTrySyncRequest(SyncFunc) ;
extern void sysDeviceInit(void) ;
extern void sysDomainInit(void) ;
#ifdef MECH_SM_TRACE
typedef struct mechtraceinfo {
    MechEventType eventType ;
    EventCode eventNumber ;
    void *srcInst ;
    void *dstInst ;
    union {
        struct normaltrace {
            StateCode currState ;
            StateCode newState ;
        } normalTrace ;
        struct polytrace {
            SubtypeCode subcode ;
            DispatchCount hierarchy ;
            EventCode mappedNumber ;
            MechEventType mappedType ;
        } polyTrace ;
        struct createtrace {
            void const *dstClass ;
        } creationTrace ;
    } info ;
} *MechTraceInfo ;
typedef void (*MechTraceCallback)(MechTraceInfo) ;
extern MechTraceCallback mechRegisterTrace(MechTraceCallback) ;
#endif  /* MECH_SM_TRACE */
typedef void (*SignalFunc)(int) ;
extern void
mechRegisterSignal(
    int sigNum,
    SignalFunc func) ;
extern void
mechRegisterFDService(
    int fd,
    FDServiceFunc readService,
    FDServiceFunc writeService,
    FDServiceFunc exceptService) ;
extern void
mechRemoveFDService(
    int fd,
    bool rmRead,
    bool rmWrite,
    bool rmExcept) ;
static inline 
void
mechEventGenerate(
    EventCode event,
    MechInstance target,
    MechInstance source)
{
    mechEventPost(mechEventNew(event, target, source)) ;
}
static inline 
void
mechEventGenerateToSelf(
    EventCode event,
    MechInstance target)
{
    mechEventPostSelf(mechEventNew(event, target, target)) ;
}
static inline 
void
mechEventGeneratePolymorphic(
    EventCode event,
    MechInstance target,
    MechInstance source)
{
    mechEventPost(mechPolyEventNew(event, target, source)) ;
}
static inline 
void
mechEventGenerateCreation(
    EventCode event,
    MechClass targetClass,
    MechInstance source)
{
    mechEventPost(mechCreationEventNew(event, targetClass,
            source)) ;
}
static inline 
void
mechEventGenerateDelayed(
    EventCode event,
    MechInstance target,
    MechInstance source,
    MechDelayTime delay)
{
    mechEventPostDelay(mechEventNew(event, target, source),
            delay) ;
}
static inline 
void
mechEventGenerateDelayedToSelf(
    EventCode event,
    MechInstance target,
    MechDelayTime delay)
{
    mechEventPostDelay(mechEventNew(event, target, target),
            delay) ;
}
#ifdef MECH_TEST
extern void stsa_main(void) ;
extern void mechInit(void) ;
extern bool mechDispatchOneEvent(void) ;
extern void mechWait(void) ;
extern bool mechInvokeOneSyncFunc(void) ;
#endif /* MECH_TEST */
#endif /* MECHS_H_ */
