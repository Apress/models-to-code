/*
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
 * Created by: C:/Users/andrewm/Working/modelrealization/modelstocode/mtc_source/tools/windows/pycca.exe/lib/application/pycca.tcl 
 * Created on: Fri Jun 23 14:16:35 PDT 2017
 * This is pycca version 4.3
 * ---------------------------------------------------------------
 */

#include <stdio.h>

#include <stddef.h>
#include <stdbool.h>
#include "mechs.h"

/*
 * The following macros may be used in the code to insulate the naming
 * conventions of "pycca" from the code.
 */
#define ClassRefType(c)             struct c *
#define ThisClassRefType            ClassRefType(THISCLASS__)
#define ClassRefVar(c, v)           struct c *v
#define ThisClassRefVar(v)          ClassRefVar(THISCLASS__, v)
#define ClassConstRefVar(c, v)      struct c const *v
#define ThisClassConstRefVar(v)     ClassConstRefVar(THISCLASS__, v)
#define ClassRefSetVar(c, v)        struct c **v
#define ThisClassRefSetVar(v)       ClassRefSetVar(THISCLASS__, v)
#define ClassRefConstSetVar(c, v)   struct c * const *v
#define ThisClassRefConstSetVar(v)  ClassRefConstSetVar(THISCLASS__, v)
#define ClassConstRefSetVar(c, v)   struct c const * const *v
#define ThisClassConstRefSetVar(v)  ClassConstRefSetVar(THISCLASS__, v)
#define SubCodeMember(r)            r ## __code
#define SubCodeValue(c, r, s)       c ## _ ## r ## _ ## s ## _CODE
#define SubTypesMember(r, s)        r . r ## _ ## s
#define RefCountMember(r)           r ## __count
#define SMName__(c, e, t)           c ## _ ## e ## t
#define EventNumber(c, e)           SMName__(c, e, _EVENT)
#define ThisClassEventNumber(e)     EventNumber(THISCLASS__, e)
#define PolyEventNumber(c, e)       SMName__(c, e, _POLYEVENT)
#define StateNumber(c, s)           SMName__(c, s, _STATE)
#define ThisClassStateNumber(s)     StateNumber(THISCLASS__, s)
#define SelfStateNumber             StateNumber(THISCLASS__, THISSTATE__)
#define ISName__(c)                 c ## _INITIAL_STATE
#define InitialStateNumber(c)       ISName__(c)
#define ThisClassInitialStateNumber InitialStateNumber(THISCLASS__)
#define EPName__(c, e)              struct c ## _ ## e ## _rcvd_evt
#define EventParamType(c, e)        EPName__(c, e)
#define EventParamDecl(c, e)        EPName__(c, e)
#define ThisClassEventParamDecl(e)  EventParamDecl(THISCLASS__, e)
#define CName__(c)                  (&c ## _class)
#define ClassData(c)                CName__(c)
#define ThisClassData               ClassData(THISCLASS__)
#define ExtStName__(d, c)           d ## _ ## c ## _storage
#define StName__(c)                 c ## _storage
#define BeginStorage(c)            StName__(c)
#define ThisClassBeginStorage       BeginStorage(THISCLASS__)
#define EndStorage(c)               (BeginStorage(c) + (sizeof(BeginStorage(c)) / sizeof(BeginStorage(c)[0])))
#define ThisClassEndStorage         EndStorage(THISCLASS__)
#define ExtIName__(d, c, n)         (ExtStName__(d, c, n) + c ## _ ## n ## _INSTANCE)
#define IName__(c, n)               (StName__(c) + c ## _ ## n ## _INSTANCE)
#define Instance(c, n)     IName__(c, n)
#define ThisClassInstance(n)     Instance(THISCLASS__, n)
#define IsInstInUse(i)      ((i)->common_.alloc != 0)
#define DomainName          sio
#define OpName(p, s)        p ## _ ## s
#define DomainOp(d, o)      OpName(d, o)
#define ExternalOp(o)       OpName(eop_ ## sio, o)
#define ClassOp(c, o)       OpName(c, o)
#define ThisClassOp(o)      ClassOp(THISCLASS__, o)
#define InstOp(c, o)        OpName(c, o)
#define ThisClassInstOp(o)  InstOp(THISCLASS__, o)

/*
 * Some convenience macros.
 */
#define PYCCA_generate(e, c, i, s) mechEventGenerate(EventNumber(c, e), (MechInstance)i, (MechInstance)s)

#define PYCCA_generateSelf(e, c) PYCCA_generate(e, c, (MechInstance)self, (MechInstance)self)

#define PYCCA_generateToSelf(e) PYCCA_generateSelf(e, THISCLASS__)

#define PYCCA_generatePolymorphic(e, c, i, s) mechEventGeneratePolymorphic(PolyEventNumber(c, e), (MechInstance)i, (MechInstance)s)

#define PYCCA_generateCreation(e, c, s) mechEventGenerateCreation(EventNumber(c, e), ClassData(c), (MechInstance)s)

#define PYCCA_generateDelayed(e, c, i, s, d) mechEventGenerateDelayed(EventNumber(c, e), (MechInstance)i, (MechInstance)s, d)

#define PYCCA_generateDelayedSelf(e, c, d) PYCCA_generateDelayed(e, c, (MechInstance)self, (MechInstance)self, d)

#define PYCCA_generateDelayedToSelf(e, d) PYCCA_generateDelayedSelf(e, THISCLASS__, d)

#define PYCCA_cancelDelayed(e, c, i, s) mechEventDelayCancel(EventNumber(c, e), (MechInstance)i, (MechInstance)s)

#define PYCCA_cancelDelayedSelf(e, c) mechEventDelayCancel(EventNumber(c, e), (MechInstance)self, (MechInstance)self)

#define PYCCA_cancelDelayedToSelf(e) PYCCA_cancelDelayedSelf(e, THISCLASS__)

#define PYCCA_remainDelayed(e, c, i, s) mechEventDelayRemaining(EventNumber(c, e), (MechInstance)i, (MechInstance)s)

#define PYCCA_remainDelayedSelf(e, c) PYCCA_remainDelayed(e, c, (MechInstance)self, (MechInstance)self)

#define PYCCA_remainDelayedToSelf(e) PYCCA_remainDelayedSelf(e, THISCLASS__)

#define PYCCA_newEvent(e, c, i, s) mechEventNew(EventNumber(c, e), (MechInstance)i, (MechInstance)s)

#define PYCCA_newSelfEvent(e, c) mechEventNew(EventNumber(c, e), (MechInstance)self, (MechInstance)self)

#define PYCCA_newEventToSelf(e) PYCCA_newSelfEvent(e, THISCLASS__)

#define PYCCA_newPolymorphicEvent(e, c, i, s) mechPolyEventNew(PolyEventNumber(c, e), (MechInstance)i, (MechInstance)s)

#define PYCCA_newCreationEvent(e, c, s) mechCreationEventNew(EventNumber(c, e), ClassData(c), (MechInstance)s)

#define PYCCA_newCreationEventForThisClass(e, s) PYCCA_newCreationEvent(e, THISCLASS__, s)

#define PYCCA_eventParam(ecb, c, e, p) ((EventParamDecl(c, e) *)(&(ecb)->eventParameters))->p

#define PYCCA_eventParamOfThisClass(ecb, e, p) PYCCA_eventParam(ecb, THISCLASS__, e, p)

#define PYCCA_postEvent(ecb) mechEventPost(ecb)

#define PYCCA_postSelfEvent(ecb) mechEventPostSelf(ecb)

#define PYCCA_postDelayedEvent(ecb, d) mechEventPostDelay(ecb, d)

#define PYCCA_createInstance(c, s) ((struct c *)mechInstCreate(ClassData(c), s))

#define PYCCA_newInstance(c)    PYCCA_createInstance(c, InitialStateNumber(c))

#define PYCCA_newInstanceOfThisClass     PYCCA_newInstance(THISCLASS__)

#define PYCCA_destroyInstance(i) (mechInstDestroy((MechInstance)i))

#define PYCCA_setToInitialState(i, c)   ((i)->common_.currentState = InitialStateNumber(c))

#define PYCCA_setToInitialStateForThisClass(i)    PYCCA_setToInitialState(i, THISCLASS__)

#define PYCCA_isSubtypeRelated(i, supc, r, subc) ((i)->SubCodeMember(r) == SubCodeValue(supc, r, subc))

#define PYCCA_unionSupertype(i, supc, r) ((struct supc *)((char *)(i) - offsetof(struct supc, r)))

#define PYCCA_unionSubtype(i, r, sub) (&((i)->SubTypesMember(r, sub)))

#define PYCCA_referenceSubtype(i, r, subc) ((struct subc *)((i)->r))

#define PYCCA_migrateSubtype(i, supc, r, subc) (i->SubCodeMember(r) = SubCodeValue(supc, r, subc))

#define PYCCA_initUnionInstance(sup, r, subc) sup->SubTypesMember(r, subc).common_.alloc = 1 ; sup->SubTypesMember(r, subc).common_.currentState = InitialStateNumber(subc) ; sup->SubTypesMember(r, subc).common_.instClass = ClassData(subc) ;

#define PYCCA_initUnionInstanceToState(sup, r, subc, st) sup->SubTypesMember(r, subc).common_.alloc = 1 ; sup->SubTypesMember(r, subc).common_.currentState = StateNumber(subc, st) ; sup->SubTypesMember(r, subc).common_.instClass = ClassData(subc) ;

#define PYCCA_forAllInst(i, c) for (i = BeginStorage(c) ; i != EndStorage(c) ; ++i)

#define PYCCA_forAllInstOfThisClass(i)   PYCCA_forAllInst(i, THISCLASS__)

#define PYCCA_forAllRelated(v, i, r) for (v = i->r ; v < i->r + i->RefCountMember(r) ; ++v)

#define PYCCA_forAllRelatedTerm(v, i, r) for (v = i->r ; *v ; ++v)

#define PYCCA_selectOneInstWhere(i, c, expr) for (i = BeginStorage(c) ; i != EndStorage(c) ; ++i) { if (IsInstInUse(i) && (expr)) {break ;}}

#define PYCCA_selectOneInstOfThisClassWhere(i, expr) PYCCA_selectOneInstWhere(i, THISCLASS__, expr) 
#define PYCCA_selectOneStaticInstWhere(i, c, expr) for (i = BeginStorage(c) ; i != EndStorage(c) ; ++i) { if ((expr)) {break ;}}

#define PYCCA_selectOneStaticInstOfThisClassWhere(i, expr) PYCCA_selectOneStaticInstWhere(i, THISCLASS__, expr)

#define PYCCA_relateSubtypeByRef(s, supc, r, t, subc) s->r = (MechInstance)t ; PYCCA_migrateSubtype(s, supc, r, subc)

#define PYCCA_relateToMany(n, o, r, m) for (n = o->r ; n < o->r + COUNTOF(o->r) ; ++n) { if (*n == NULL) { *n = m ; break ; } } assert(n < o->r + COUNTOF(o->r))

#define PYCCA_unrelateFromMany(n, o, r, m) for (n = o->r ; n < o->r + COUNTOF(o->r) ; ++n) { if (*n == m) { *n = NULL ; break ; } } assert(n < o->r + COUNTOF(o->r))

#define PYCCA_linkToMany(o, r, m) rlinkInsert(&m->r##__links, &o->r)

#define PYCCA_unlinkFromMany(m, r) rlinkRemove(&m->r##__links)

#define PYCCA_linkToInstRef(l, c, r) ((struct c *)((char *)(l) - offsetof(struct c, r##__links)))

#define PYCCA_linkToInstRefOfThisClass(l, r) PYCCA_linkToInstRef(l, THISCLASS__, r)

#define PYCCA_forAllLinkedInst(i, r, l) for (l = rlinkBegin(&i->r) ; l != rlinkEnd(&i->r) ; l = l->next)

#define PYCCA_isLinkEmpty(i, r) rlinkEmpty(&i->r)

#define PYCCA_isLinkNotEmpty(i, r) rlinkNotEmpty(&i->r)

#define PYCCA_idOfSelf              (self - ThisClassBeginStorage)

#define PYCCA_idOfRef(c, r)         ((r) - BeginStorage(c))

#define PYCCA_idOfInst(c, n)        (Instance(c, n) - BeginStorage(c))

#define PYCCA_refOfId(c, i)         (BeginStorage(c) + (i))

#define PYCCA_refOfThisClassId(i)   (ThisClassBeginStorage + (i))

#define PYCCA_checkId(c, i)         assert((i) < COUNTOF(BeginStorage(c)))

#define PYCCA_checkThisClassId(i)   assert((i) < COUNTOF(ThisClassBeginStorage))

#ifndef COUNTOF
#define COUNTOF(a)  (sizeof(a) / sizeof(a[0]))
#endif /* COUNTOF */

/*
 * Code for Domain, "sio"
 */

#define INSTRUMENT 1

/*
 * implementation prolog code
 */

#include <assert.h>
#include "sio.h"
typedef uint32_t Point_Value_Mask ;
typedef int Count ;
typedef uint32_t Msec ;
typedef enum {ReadWrite, ReadOnly, WriteOnly} Access_Type ;
typedef enum {Memory, ReadClear, ReadClearZero} Memory_Type ;
typedef enum {Inactive, Active, BothActive} Edge_Type ;
typedef uint8_t Bit_Count ;
typedef uint8_t Bit_Offset ;
typedef enum {Rising, Falling} Excursion_Direction ;


#ifdef INSTRUMENT
#   ifndef INSTR_FUNC
#       ifdef TACK
#           include "harness.h"
#           define INSTR_FUNC(s) harness_stub_printf("instrument", "func %s file %s line %u", (s), __FILE__, __LINE__)
#       else
#           define INSTR_FUNC(s) printf("%s: %s %d\n", (s), __FILE__, __LINE__)
#       endif /* TACK */
#   endif /* INSTR_FUNC */
#endif /* INSTRUMENT */

/*
 * External Operations Declarations
 */
extern void eop_sio_NOTIFY_New_point_value(sio_Point_ID point, sio_Point_Value value) ;
extern void eop_sio_NOTIFY_In_range(sio_Point_ID point, sio_Threshold_ID threshold) ;
extern void eop_sio_NOTIFY_Out_of_range(sio_Point_ID point, sio_Threshold_ID threshold) ;
extern void eop_sio_NOTIFY_Signal_point(sio_Point_ID point, bool isActive) ;
extern void eop_sio_DEVICE_Convert_group(sio_Converter_ID converter, sio_Group_ID group) ;
extern sio_Point_Value eop_sio_DEVICE_Read_converted_value(sio_Converter_ID converter, sio_Point_ID point) ;
extern void eop_sio_DEVICE_Write_reg(sio_Point_ID pid, sio_Point_Value value) ;
extern sio_Point_Value eop_sio_DEVICE_Read_reg(sio_Point_ID pid) ;
extern void eop_sio_DEVICE_Enable_signal(sio_Point_ID pid) ;
extern void eop_sio_DEVICE_Disable_signal(sio_Point_ID pid) ;


/*
 * State Numbering
 */
/*
 * State Numbers for Class, "Signalling_Point"
 */
#define Signalling_Point_OFF_STATE 0
#define Signalling_Point_INITIAL_STATE 0
#define Signalling_Point_ON_STATE 1
#define Signalling_Point_DEBOUNCING_STATE 2
#define Signalling_Point_CONFIRMING_STATE 3
/*
 * State Numbers for Class, "Range_Limitation"
 */
#define Range_Limitation_IN_RANGE_STATE 0
#define Range_Limitation_INITIAL_STATE 0
#define Range_Limitation_CHECKING_OUT_OF_RANGE_STATE 1
#define Range_Limitation_OUT_OF_RANGE_STATE 2
#define Range_Limitation_CHECKING_IN_RANGE_STATE 3
/*
 * State Numbers for Class, "Signal_Converter"
 */
#define Signal_Converter_CONVERSION_COMPLETE_STATE 0
#define Signal_Converter_INITIAL_STATE 0
#define Signal_Converter_CONVERTING_STATE 1
/*
 * State Numbers for Class, "Conversion_Group"
 */
#define Conversion_Group_FINISHED_STATE 0
#define Conversion_Group_INITIAL_STATE 0
#define Conversion_Group_WAITING_FOR_CONVERSION_STATE 1
#define Conversion_Group_CONVERSION_COMPLETED_STATE 2
/*
 * State Numbers for Class, "R6_Assigner"
 */
#define R6_Assigner_WAITING_FOR_GROUP_STATE 0
#define R6_Assigner_INITIAL_STATE 0
#define R6_Assigner_WAITING_FOR_CONVERTER_STATE 1
#define R6_Assigner_Assigning_Converter_STATE 2
/*
 * Pseudo initial states for inactive classes.
 */
#define IO_Point_INITIAL_STATE 0
#define Discrete_Point_INITIAL_STATE 0
#define Continuous_Point_INITIAL_STATE 0
#define Packed_Point_INITIAL_STATE 0
#define Control_Point_INITIAL_STATE 0
#define Continuous_Output_Point_INITIAL_STATE 0
#define Continuous_Input_Point_INITIAL_STATE 0
#define Point_Scaling_INITIAL_STATE 0
#define Point_Threshold_INITIAL_STATE 0

/*
 * Event Numbering
 */
/*
 * Event Numbers for Class, "Signalling_Point"
 */
#define Signalling_Point_Confirm_EVENT 0
#define Signalling_Point_Off_EVENT 1
#define Signalling_Point_On_EVENT 2
#define Signalling_Point_Trigger_EVENT 3
/*
 * Event Numbers for Class, "Range_Limitation"
 */
#define Range_Limitation_In_range_EVENT 0
#define Range_Limitation_New_point_EVENT 1
#define Range_Limitation_Out_of_range_EVENT 2
/*
 * Event Numbers for Class, "Signal_Converter"
 */
#define Signal_Converter_Conversion_done_EVENT 0
#define Signal_Converter_Converter_assigned_EVENT 1
/*
 * Event Numbers for Class, "Conversion_Group"
 */
#define Conversion_Group_Conversion_done_EVENT 0
#define Conversion_Group_Sample_EVENT 1
#define Conversion_Group_Stop_EVENT 2
/*
 * Event Numbers for Class, "R6_Assigner"
 */
#define R6_Assigner_Converter_assigned_EVENT 0
#define R6_Assigner_Converter_ready_EVENT 1
#define R6_Assigner_Group_ready_EVENT 2

/*
 * Subtype Numbering
 */
/*
 * Subtype Numbers for IO_Point / R1
 */
#define IO_Point_R1_Discrete_Point_CODE 0
#define IO_Point_R1_Signalling_Point_CODE 1
#define IO_Point_R1_Continuous_Point_CODE 2
/*
 * Subtype Numbers for Discrete_Point / R8
 */
#define Discrete_Point_R8_Packed_Point_CODE 0
#define Discrete_Point_R8_Control_Point_CODE 1
/*
 * Subtype Numbers for Continuous_Point / R2
 */
#define Continuous_Point_R2_Continuous_Output_Point_CODE 0
#define Continuous_Point_R2_Continuous_Input_Point_CODE 1

/*
 * Offsets to named instances
 */
#define IO_Point_iop1_INSTANCE 0
#define IO_Point_iop2_INSTANCE 1
#define IO_Point_iop3_INSTANCE 2
#define IO_Point_iop4_INSTANCE 3
#define IO_Point_iop5_INSTANCE 4
#define IO_Point_iop6_INSTANCE 5
#define IO_Point_iop7_INSTANCE 6
#define IO_Point_iop8_INSTANCE 7
#define IO_Point_iop9_INSTANCE 8
#define IO_Point_iop10_INSTANCE 9
#define IO_Point_iop11_INSTANCE 10
#define Discrete_Point_iop4_INSTANCE 0
#define Discrete_Point_iop5_INSTANCE 1
#define Discrete_Point_iop6_INSTANCE 2
#define Signalling_Point_iop7_INSTANCE 0
#define Signalling_Point_iop8_INSTANCE 1
#define Signalling_Point_iop9_INSTANCE 2
#define Signalling_Point_iop10_INSTANCE 3
#define Signalling_Point_iop11_INSTANCE 4
#define Continuous_Point_iop1_INSTANCE 0
#define Continuous_Point_iop2_INSTANCE 1
#define Continuous_Point_iop3_INSTANCE 2
#define Control_Point_iop4_INSTANCE 0
#define Control_Point_iop5_INSTANCE 1
#define Control_Point_iop6_INSTANCE 2
#define Continuous_Input_Point_iop1_INSTANCE 0
#define Continuous_Input_Point_iop2_INSTANCE 1
#define Continuous_Input_Point_iop3_INSTANCE 2
#define Point_Scaling_ihn4_pres_scale_INSTANCE 0
#define Point_Scaling_ix77b_pres_scale_INSTANCE 1
#define Point_Threshold_ix77b_above_disp_INSTANCE 0
#define Point_Threshold_ix77b_above_inj_INSTANCE 1
#define Point_Threshold_ix77b_max_pres_INSTANCE 2
#define Point_Threshold_ihn4_above_disp_INSTANCE 3
#define Point_Threshold_ihn4_above_inj_INSTANCE 4
#define Point_Threshold_ihn4_max_pres_INSTANCE 5
#define Range_Limitation_above_disp_iop1_INSTANCE 0
#define Range_Limitation_above_inj_iop1_INSTANCE 1
#define Range_Limitation_max_pres_iop1_INSTANCE 2
#define Range_Limitation_above_disp_iop2_INSTANCE 3
#define Range_Limitation_above_inj_iop2_INSTANCE 4
#define Range_Limitation_max_pres_iop2_INSTANCE 5
#define Range_Limitation_above_disp_iop3_INSTANCE 6
#define Range_Limitation_above_inj_iop3_INSTANCE 7
#define Range_Limitation_max_pres_iop3_INSTANCE 8
#define Signal_Converter_cvt1_INSTANCE 0
#define Conversion_Group_inj1_cg_INSTANCE 0
#define Conversion_Group_inj2_cg_INSTANCE 1
#define Conversion_Group_inj3_cg_INSTANCE 2
#define R6_Assigner_r6asgn1_INSTANCE 0

/*
 * Forward class structure declarations
 */
struct IO_Point ;
struct Discrete_Point ;
struct Signalling_Point ;
struct Continuous_Point ;
struct Packed_Point ;
struct Control_Point ;
struct Continuous_Output_Point ;
struct Continuous_Input_Point ;
struct Point_Scaling ;
struct Point_Threshold ;
struct Range_Limitation ;
struct Signal_Converter ;
struct Conversion_Group ;
struct R6_Assigner ;

/*
 * Class structure definitions
 */
struct Continuous_Output_Point {
} ;
struct Continuous_Input_Point {
    sio_Point_Value Value ;
    struct Range_Limitation *const*const R7 ;
    unsigned R7__count ;
    struct Conversion_Group *R4 ;
} ;
struct Packed_Point {
    Bit_Count Length ;
    Bit_Offset Offset ;
    struct Control_Point *R9 ;
} ;
struct Control_Point {
    Memory_Type Memory_model ;
    Access_Type Access ;
} ;
struct Discrete_Point {
    SubtypeCode R8__code ;
    union {
        struct Packed_Point R8_Packed_Point ;
        struct Control_Point R8_Control_Point ;
    } R8 ;
} ;
struct Signalling_Point {
    struct mechinstance common_ ; // must be first !
    sio_Point_Value Value ;
    Edge_Type Trigger ;
    bool Active_high ;
    Msec Debounce_time ;
} ;
struct Continuous_Point {
    struct Point_Scaling *R3 ;
    SubtypeCode R2__code ;
    union {
        struct Continuous_Output_Point R2_Continuous_Output_Point ;
        struct Continuous_Input_Point R2_Continuous_Input_Point ;
    } R2 ;
} ;
struct IO_Point {
    SubtypeCode R1__code ;
    union {
        struct Discrete_Point R1_Discrete_Point ;
        struct Signalling_Point R1_Signalling_Point ;
        struct Continuous_Point R1_Continuous_Point ;
    } R1 ;
} ;
struct Point_Scaling {
    sio_Point_Value Multiplier ;
    sio_Point_Value Divisor ;
    sio_Point_Value Intercept ;
    Point_Value_Mask Mask ;
} ;
struct Point_Threshold {
    sio_Point_Value Limit ;
    Excursion_Direction Direction ;
    Count Over_limit ;
    Count Under_limit ;
} ;
struct Range_Limitation {
    struct mechinstance common_ ; // must be first !
    Count Over_count ;
    Count Under_count ;
    struct Point_Threshold *R7_PT ;
    struct Continuous_Input_Point *R7_CIP ;
} ;
struct Signal_Converter {
    struct mechinstance common_ ; // must be first !
    bool Converter_available ;
    struct Conversion_Group *const*const R5 ;
    unsigned R5__count ;
    struct Conversion_Group *R6 ;
    struct R6_Assigner *assigner ;
} ;
struct Conversion_Group {
    struct mechinstance common_ ; // must be first !
    bool Waiting_for_converter ;
    Msec Period ;
    struct Continuous_Input_Point *const*const R4 ;
    unsigned R4__count ;
    struct Signal_Converter *R5 ;
} ;
struct R6_Assigner {
    struct mechinstance common_ ; // must be first !
    struct Signal_Converter *idclass ;
} ;

/*
 * Event Parameter Structure Definitions
 */
struct Range_Limitation_New_point_rcvd_evt {
    sio_Point_Value pointValue ;
} ;


/*
 * Forward Operation Function Declarations
 */
static sio_Point_Value IO_Point_readPoint(struct IO_Point *self) ;
static void IO_Point_writePoint(struct IO_Point *self, sio_Point_Value value) ;
static sio_Point_Value Discrete_Point_readPoint(struct Discrete_Point *self) ;
static void Discrete_Point_writePoint(struct Discrete_Point *self, sio_Point_Value value) ;
static void Signalling_Point_evalSignal(struct Signalling_Point *self) ;
static sio_Point_Value Signalling_Point_readPoint(struct Signalling_Point *self) ;
static sio_Point_Value Continuous_Point_readPoint(struct Continuous_Point *self) ;
static void Continuous_Point_writePoint(struct Continuous_Point *self, sio_Point_Value value) ;
static sio_Point_Value Packed_Point_readPoint(struct Packed_Point *self) ;
static void Packed_Point_writePoint(struct Packed_Point *self, sio_Point_Value value) ;
static sio_Point_Value Control_Point_readPoint(struct Control_Point *self) ;
static void Control_Point_writePoint(struct Control_Point *self, sio_Point_Value value) ;
static void Continuous_Input_Point_updateValue(struct Continuous_Input_Point *self, sio_Point_Value value) ;
static sio_Point_Value Point_Scaling_scaleValueIn(struct Point_Scaling *self, sio_Point_Value value) ;
static sio_Point_Value Point_Scaling_scaleValueOut(struct Point_Scaling *self, sio_Point_Value value) ;

/*
 * Forward Declarations of Class Constructors
 */

/*
 * Forward Declarations of Class Destructors
 */

/*
 * Forward Declarations of State Action Functions
 */
static void Conversion_Group_CONVERSION_COMPLETED(void *const s_, void *const p_) ;
static void Conversion_Group_FINISHED(void *const s_, void *const p_) ;
static void Conversion_Group_WAITING_FOR_CONVERSION(void *const s_, void *const p_) ;
static void R6_Assigner_Assigning_Converter(void *const s_, void *const p_) ;
static void R6_Assigner_WAITING_FOR_CONVERTER(void *const s_, void *const p_) ;
static void R6_Assigner_WAITING_FOR_GROUP(void *const s_, void *const p_) ;
static void Range_Limitation_CHECKING_IN_RANGE(void *const s_, void *const p_) ;
static void Range_Limitation_CHECKING_OUT_OF_RANGE(void *const s_, void *const p_) ;
static void Range_Limitation_IN_RANGE(void *const s_, void *const p_) ;
static void Range_Limitation_OUT_OF_RANGE(void *const s_, void *const p_) ;
static void Signal_Converter_CONVERSION_COMPLETE(void *const s_, void *const p_) ;
static void Signal_Converter_CONVERTING(void *const s_, void *const p_) ;
static void Signalling_Point_CONFIRMING(void *const s_, void *const p_) ;
static void Signalling_Point_DEBOUNCING(void *const s_, void *const p_) ;
static void Signalling_Point_OFF(void *const s_, void *const p_) ;
static void Signalling_Point_ON(void *const s_, void *const p_) ;

/*
 * Domain Operations External Declarations
 */
extern sio_Point_Value sio_Read_point(sio_Point_ID pid) ;
extern void sio_Write_point(sio_Point_ID pid, sio_Point_Value value) ;
extern void sio_init(void) ;

/*
 * Declaration of Function to Construct Initial Instances
 */

/*
 * Forward Instance Storage Declarations
 */
static struct IO_Point IO_Point_storage[] ;
static struct Point_Scaling Point_Scaling_storage[] ;
static struct Point_Threshold Point_Threshold_storage[] ;
static struct Range_Limitation Range_Limitation_storage[] ;
static struct Signal_Converter Signal_Converter_storage[] ;
static struct Conversion_Group Conversion_Group_storage[] ;
static struct R6_Assigner R6_Assigner_storage[] ;


/*
 * Instance Allocation Block Definitions
 */

/*
 * AODB for Class, "Signalling_Point"
 */
static PtrActionFunction const Signalling_Point_acttbl[] = {
    Signalling_Point_OFF,
    Signalling_Point_ON,
    Signalling_Point_DEBOUNCING,
    Signalling_Point_CONFIRMING,
} ;
static StateCode const Signalling_Point_transtbl[] = {
    MECH_STATECODE_CH, // OFF - Confirm -> CH
    MECH_STATECODE_IG, // OFF - Off -> IG
    1, // OFF - On -> ON
    MECH_STATECODE_IG, // OFF - Trigger -> IG
    MECH_STATECODE_CH, // ON - Confirm -> CH
    0, // ON - Off -> OFF
    MECH_STATECODE_IG, // ON - On -> IG
    2, // ON - Trigger -> DEBOUNCING
    3, // DEBOUNCING - Confirm -> CONFIRMING
    0, // DEBOUNCING - Off -> OFF
    MECH_STATECODE_IG, // DEBOUNCING - On -> IG
    MECH_STATECODE_IG, // DEBOUNCING - Trigger -> IG
    MECH_STATECODE_CH, // CONFIRMING - Confirm -> CH
    0, // CONFIRMING - Off -> OFF
    MECH_STATECODE_IG, // CONFIRMING - On -> IG
    2, // CONFIRMING - Trigger -> DEBOUNCING
} ;
static struct objectdispatchblock const Signalling_Point_odb = {
    .stateCount = 4,
    .eventCount = 4,
    .transitionTable = Signalling_Point_transtbl,
    .actionTable = Signalling_Point_acttbl,
    .finalStates = NULL
} ;
/*
 * AODB for Class, "Range_Limitation"
 */
static PtrActionFunction const Range_Limitation_acttbl[] = {
    Range_Limitation_IN_RANGE,
    Range_Limitation_CHECKING_OUT_OF_RANGE,
    Range_Limitation_OUT_OF_RANGE,
    Range_Limitation_CHECKING_IN_RANGE,
} ;
static StateCode const Range_Limitation_transtbl[] = {
    MECH_STATECODE_CH, // IN_RANGE - In_range -> CH
    1, // IN_RANGE - New_point -> CHECKING_OUT_OF_RANGE
    MECH_STATECODE_CH, // IN_RANGE - Out_of_range -> CH
    MECH_STATECODE_CH, // CHECKING_OUT_OF_RANGE - In_range -> CH
    1, // CHECKING_OUT_OF_RANGE - New_point -> CHECKING_OUT_OF_RANGE
    2, // CHECKING_OUT_OF_RANGE - Out_of_range -> OUT_OF_RANGE
    MECH_STATECODE_CH, // OUT_OF_RANGE - In_range -> CH
    3, // OUT_OF_RANGE - New_point -> CHECKING_IN_RANGE
    MECH_STATECODE_CH, // OUT_OF_RANGE - Out_of_range -> CH
    0, // CHECKING_IN_RANGE - In_range -> IN_RANGE
    3, // CHECKING_IN_RANGE - New_point -> CHECKING_IN_RANGE
    MECH_STATECODE_CH, // CHECKING_IN_RANGE - Out_of_range -> CH
} ;
static struct objectdispatchblock const Range_Limitation_odb = {
    .stateCount = 4,
    .eventCount = 3,
    .transitionTable = Range_Limitation_transtbl,
    .actionTable = Range_Limitation_acttbl,
    .finalStates = NULL
} ;
/*
 * AODB for Class, "Signal_Converter"
 */
static PtrActionFunction const Signal_Converter_acttbl[] = {
    Signal_Converter_CONVERSION_COMPLETE,
    Signal_Converter_CONVERTING,
} ;
static StateCode const Signal_Converter_transtbl[] = {
    MECH_STATECODE_CH, // CONVERSION_COMPLETE - Conversion_done -> CH
    1, // CONVERSION_COMPLETE - Converter_assigned -> CONVERTING
    0, // CONVERTING - Conversion_done -> CONVERSION_COMPLETE
    MECH_STATECODE_CH, // CONVERTING - Converter_assigned -> CH
} ;
static struct objectdispatchblock const Signal_Converter_odb = {
    .stateCount = 2,
    .eventCount = 2,
    .transitionTable = Signal_Converter_transtbl,
    .actionTable = Signal_Converter_acttbl,
    .finalStates = NULL
} ;
/*
 * AODB for Class, "Conversion_Group"
 */
static PtrActionFunction const Conversion_Group_acttbl[] = {
    Conversion_Group_FINISHED,
    Conversion_Group_WAITING_FOR_CONVERSION,
    Conversion_Group_CONVERSION_COMPLETED,
} ;
static StateCode const Conversion_Group_transtbl[] = {
    MECH_STATECODE_IG, // FINISHED - Conversion_done -> IG
    1, // FINISHED - Sample -> WAITING_FOR_CONVERSION
    MECH_STATECODE_IG, // FINISHED - Stop -> IG
    2, // WAITING_FOR_CONVERSION - Conversion_done -> CONVERSION_COMPLETED
    1, // WAITING_FOR_CONVERSION - Sample -> WAITING_FOR_CONVERSION
    0, // WAITING_FOR_CONVERSION - Stop -> FINISHED
    MECH_STATECODE_CH, // CONVERSION_COMPLETED - Conversion_done -> CH
    1, // CONVERSION_COMPLETED - Sample -> WAITING_FOR_CONVERSION
    0, // CONVERSION_COMPLETED - Stop -> FINISHED
} ;
static struct objectdispatchblock const Conversion_Group_odb = {
    .stateCount = 3,
    .eventCount = 3,
    .transitionTable = Conversion_Group_transtbl,
    .actionTable = Conversion_Group_acttbl,
    .finalStates = NULL
} ;
/*
 * AODB for Class, "R6_Assigner"
 */
static PtrActionFunction const R6_Assigner_acttbl[] = {
    R6_Assigner_WAITING_FOR_GROUP,
    R6_Assigner_WAITING_FOR_CONVERTER,
    R6_Assigner_Assigning_Converter,
} ;
static StateCode const R6_Assigner_transtbl[] = {
    MECH_STATECODE_CH, // WAITING_FOR_GROUP - Converter_assigned -> CH
    MECH_STATECODE_IG, // WAITING_FOR_GROUP - Converter_ready -> IG
    1, // WAITING_FOR_GROUP - Group_ready -> WAITING_FOR_CONVERTER
    MECH_STATECODE_CH, // WAITING_FOR_CONVERTER - Converter_assigned -> CH
    2, // WAITING_FOR_CONVERTER - Converter_ready -> Assigning_Converter
    MECH_STATECODE_IG, // WAITING_FOR_CONVERTER - Group_ready -> IG
    0, // Assigning_Converter - Converter_assigned -> WAITING_FOR_GROUP
    MECH_STATECODE_IG, // Assigning_Converter - Converter_ready -> IG
    MECH_STATECODE_IG, // Assigning_Converter - Group_ready -> IG
} ;
static struct objectdispatchblock const R6_Assigner_odb = {
    .stateCount = 3,
    .eventCount = 3,
    .transitionTable = R6_Assigner_transtbl,
    .actionTable = R6_Assigner_acttbl,
    .finalStates = NULL
} ;


/*
 * Class Structure for, "Signalling_Point"
 */
static struct mechclass const Signalling_Point_class = {
    .iab = NULL,
    .odb = &Signalling_Point_odb,
    .pdb = NULL
} ;
/*
 * Class Structure for, "Range_Limitation"
 */
static struct mechclass const Range_Limitation_class = {
    .iab = NULL,
    .odb = &Range_Limitation_odb,
    .pdb = NULL
} ;
/*
 * Class Structure for, "Signal_Converter"
 */
static struct mechclass const Signal_Converter_class = {
    .iab = NULL,
    .odb = &Signal_Converter_odb,
    .pdb = NULL
} ;
/*
 * Class Structure for, "Conversion_Group"
 */
static struct mechclass const Conversion_Group_class = {
    .iab = NULL,
    .odb = &Conversion_Group_odb,
    .pdb = NULL
} ;
/*
 * Class Structure for, "R6_Assigner"
 */
static struct mechclass const R6_Assigner_class = {
    .iab = NULL,
    .odb = &R6_Assigner_odb,
    .pdb = NULL
} ;


/*
 * Data Portal data structures
 */
#include "pycca_portal.h"
static struct pycca_attr_portal const IO_Point_attr_portal[1] = {
    {.offset = offsetof(struct IO_Point, R1__code), .size = sizeof(IO_Point_storage->R1__code)},
} ;
static struct pycca_attr_portal const Discrete_Point_attr_portal[1] = {
    {.offset = offsetof(struct Discrete_Point, R8__code), .size = sizeof(IO_Point_storage->R1.R1_Discrete_Point.R8__code)},
} ;
static struct pycca_attr_portal const Signalling_Point_attr_portal[4] = {
    {.offset = offsetof(struct Signalling_Point, Value), .size = sizeof(IO_Point_storage->R1.R1_Signalling_Point.Value)},
    {.offset = offsetof(struct Signalling_Point, Trigger), .size = sizeof(IO_Point_storage->R1.R1_Signalling_Point.Trigger)},
    {.offset = offsetof(struct Signalling_Point, Active_high), .size = sizeof(IO_Point_storage->R1.R1_Signalling_Point.Active_high)},
    {.offset = offsetof(struct Signalling_Point, Debounce_time), .size = sizeof(IO_Point_storage->R1.R1_Signalling_Point.Debounce_time)},
} ;
static struct pycca_attr_portal const Continuous_Point_attr_portal[1] = {
    {.offset = offsetof(struct Continuous_Point, R2__code), .size = sizeof(IO_Point_storage->R1.R1_Continuous_Point.R2__code)},
} ;
static struct pycca_attr_portal const Packed_Point_attr_portal[2] = {
    {.offset = offsetof(struct Packed_Point, Length), .size = sizeof(IO_Point_storage->R1.R1_Discrete_Point.R8.R8_Packed_Point.Length)},
    {.offset = offsetof(struct Packed_Point, Offset), .size = sizeof(IO_Point_storage->R1.R1_Discrete_Point.R8.R8_Packed_Point.Offset)},
} ;
static struct pycca_attr_portal const Control_Point_attr_portal[2] = {
    {.offset = offsetof(struct Control_Point, Memory_model), .size = sizeof(IO_Point_storage->R1.R1_Discrete_Point.R8.R8_Control_Point.Memory_model)},
    {.offset = offsetof(struct Control_Point, Access), .size = sizeof(IO_Point_storage->R1.R1_Discrete_Point.R8.R8_Control_Point.Access)},
} ;
static struct pycca_attr_portal const Continuous_Input_Point_attr_portal[1] = {
    {.offset = offsetof(struct Continuous_Input_Point, Value), .size = sizeof(IO_Point_storage->R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point.Value)},
} ;
static struct pycca_attr_portal const Point_Scaling_attr_portal[4] = {
    {.offset = offsetof(struct Point_Scaling, Multiplier), .size = sizeof(Point_Scaling_storage->Multiplier)},
    {.offset = offsetof(struct Point_Scaling, Divisor), .size = sizeof(Point_Scaling_storage->Divisor)},
    {.offset = offsetof(struct Point_Scaling, Intercept), .size = sizeof(Point_Scaling_storage->Intercept)},
    {.offset = offsetof(struct Point_Scaling, Mask), .size = sizeof(Point_Scaling_storage->Mask)},
} ;
static struct pycca_attr_portal const Point_Threshold_attr_portal[4] = {
    {.offset = offsetof(struct Point_Threshold, Limit), .size = sizeof(Point_Threshold_storage->Limit)},
    {.offset = offsetof(struct Point_Threshold, Direction), .size = sizeof(Point_Threshold_storage->Direction)},
    {.offset = offsetof(struct Point_Threshold, Over_limit), .size = sizeof(Point_Threshold_storage->Over_limit)},
    {.offset = offsetof(struct Point_Threshold, Under_limit), .size = sizeof(Point_Threshold_storage->Under_limit)},
} ;
static struct pycca_attr_portal const Range_Limitation_attr_portal[2] = {
    {.offset = offsetof(struct Range_Limitation, Over_count), .size = sizeof(Range_Limitation_storage->Over_count)},
    {.offset = offsetof(struct Range_Limitation, Under_count), .size = sizeof(Range_Limitation_storage->Under_count)},
} ;
static struct pycca_attr_portal const Signal_Converter_attr_portal[1] = {
    {.offset = offsetof(struct Signal_Converter, Converter_available), .size = sizeof(Signal_Converter_storage->Converter_available)},
} ;
static struct pycca_attr_portal const Conversion_Group_attr_portal[2] = {
    {.offset = offsetof(struct Conversion_Group, Waiting_for_converter), .size = sizeof(Conversion_Group_storage->Waiting_for_converter)},
    {.offset = offsetof(struct Conversion_Group, Period), .size = sizeof(Conversion_Group_storage->Period)},
} ;
static struct pycca_class_portal const sio_class_portal[] = {
    {.storage = IO_Point_storage, .attrs = IO_Point_attr_portal, .mechClass = NULL, .numAttrs = 1, .numInsts = 11, .instSize = sizeof(struct IO_Point), .instOffset = 0, .isConst = 0, .hasCommon = 0, .initialState = IO_Point_INITIAL_STATE},
    {.storage = IO_Point_storage, .attrs = Discrete_Point_attr_portal, .mechClass = NULL, .numAttrs = 1, .numInsts = 11, .instSize = sizeof(struct IO_Point), .instOffset = offsetof(struct IO_Point, R1.R1_Discrete_Point), .isConst = 0, .hasCommon = 0, .initialState = Discrete_Point_INITIAL_STATE},
    {.storage = IO_Point_storage, .attrs = Signalling_Point_attr_portal, .mechClass = &Signalling_Point_class, .numAttrs = 4, .numInsts = 11, .instSize = sizeof(struct IO_Point), .instOffset = offsetof(struct IO_Point, R1.R1_Signalling_Point), .isConst = 0, .hasCommon = 1, .initialState = Signalling_Point_INITIAL_STATE},
    {.storage = IO_Point_storage, .attrs = Continuous_Point_attr_portal, .mechClass = NULL, .numAttrs = 1, .numInsts = 11, .instSize = sizeof(struct IO_Point), .instOffset = offsetof(struct IO_Point, R1.R1_Continuous_Point), .isConst = 0, .hasCommon = 0, .initialState = Continuous_Point_INITIAL_STATE},
    {.storage = IO_Point_storage, .attrs = Packed_Point_attr_portal, .mechClass = NULL, .numAttrs = 2, .numInsts = 11, .instSize = sizeof(struct IO_Point), .instOffset = offsetof(struct IO_Point, R1.R1_Discrete_Point.R8.R8_Packed_Point), .isConst = 0, .hasCommon = 0, .initialState = Packed_Point_INITIAL_STATE},
    {.storage = IO_Point_storage, .attrs = Control_Point_attr_portal, .mechClass = NULL, .numAttrs = 2, .numInsts = 11, .instSize = sizeof(struct IO_Point), .instOffset = offsetof(struct IO_Point, R1.R1_Discrete_Point.R8.R8_Control_Point), .isConst = 0, .hasCommon = 0, .initialState = Control_Point_INITIAL_STATE},
    {.storage = IO_Point_storage, .attrs = Continuous_Input_Point_attr_portal, .mechClass = NULL, .numAttrs = 1, .numInsts = 11, .instSize = sizeof(struct IO_Point), .instOffset = offsetof(struct IO_Point, R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point), .isConst = 0, .hasCommon = 0, .initialState = Continuous_Input_Point_INITIAL_STATE},
    {.storage = Point_Scaling_storage, .attrs = Point_Scaling_attr_portal, .mechClass = NULL, .numAttrs = 4, .numInsts = 2, .instSize = sizeof(struct Point_Scaling), .instOffset = 0, .isConst = 0, .hasCommon = 0, .initialState = Point_Scaling_INITIAL_STATE},
    {.storage = Point_Threshold_storage, .attrs = Point_Threshold_attr_portal, .mechClass = NULL, .numAttrs = 4, .numInsts = 6, .instSize = sizeof(struct Point_Threshold), .instOffset = 0, .isConst = 0, .hasCommon = 0, .initialState = Point_Threshold_INITIAL_STATE},
    {.storage = Range_Limitation_storage, .attrs = Range_Limitation_attr_portal, .mechClass = &Range_Limitation_class, .numAttrs = 2, .numInsts = 9, .instSize = sizeof(struct Range_Limitation), .instOffset = 0, .isConst = 0, .hasCommon = 1, .initialState = Range_Limitation_INITIAL_STATE},
    {.storage = Signal_Converter_storage, .attrs = Signal_Converter_attr_portal, .mechClass = &Signal_Converter_class, .numAttrs = 1, .numInsts = 1, .instSize = sizeof(struct Signal_Converter), .instOffset = 0, .isConst = 0, .hasCommon = 1, .initialState = Signal_Converter_INITIAL_STATE},
    {.storage = Conversion_Group_storage, .attrs = Conversion_Group_attr_portal, .mechClass = &Conversion_Group_class, .numAttrs = 2, .numInsts = 3, .instSize = sizeof(struct Conversion_Group), .instOffset = 0, .isConst = 0, .hasCommon = 1, .initialState = Conversion_Group_INITIAL_STATE},
    {.storage = R6_Assigner_storage, .attrs = NULL, .mechClass = &R6_Assigner_class, .numAttrs = 0, .numInsts = 1, .instSize = sizeof(struct R6_Assigner), .instOffset = 0, .isConst = 0, .hasCommon = 1, .initialState = R6_Assigner_INITIAL_STATE},
} ;
struct pycca_domain_portal const sio_portal = {
    .classes = sio_class_portal,
    .numClasses = 13
} ;

/*
 * Multi-ref pointer arrays
 */
static struct Range_Limitation *const Continuous_Input_Point_R7_28_refs[] = {
    &Range_Limitation_storage[0],
    &Range_Limitation_storage[1],
    &Range_Limitation_storage[2],
} ;
static struct Range_Limitation *const Continuous_Input_Point_R7_29_refs[] = {
    &Range_Limitation_storage[3],
    &Range_Limitation_storage[4],
    &Range_Limitation_storage[5],
} ;
static struct Range_Limitation *const Continuous_Input_Point_R7_30_refs[] = {
    &Range_Limitation_storage[6],
    &Range_Limitation_storage[7],
    &Range_Limitation_storage[8],
} ;
static struct Conversion_Group *const Signal_Converter_R5_49_refs[] = {
    &Conversion_Group_storage[0],
    &Conversion_Group_storage[1],
    &Conversion_Group_storage[2],
} ;
static struct Continuous_Input_Point *const Conversion_Group_R4_46_refs[] = {
    &IO_Point_storage[0].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point,
} ;
static struct Continuous_Input_Point *const Conversion_Group_R4_47_refs[] = {
    &IO_Point_storage[1].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point,
} ;
static struct Continuous_Input_Point *const Conversion_Group_R4_48_refs[] = {
    &IO_Point_storage[2].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point,
} ;

/*
 * Initial Instance Storage for, "IO_Point"
 */
static struct IO_Point IO_Point_storage[11] = {
    {.R1__code = 2, .R1 = {.R1_Continuous_Point = {.R3 = &Point_Scaling_storage[1], .R2__code = 1, .R2 = {.R2_Continuous_Input_Point = {0, .R7 = Continuous_Input_Point_R7_28_refs, .R7__count = COUNTOF(Continuous_Input_Point_R7_28_refs), .R4 = &Conversion_Group_storage[0]}}}}},
    {.R1__code = 2, .R1 = {.R1_Continuous_Point = {.R3 = &Point_Scaling_storage[0], .R2__code = 1, .R2 = {.R2_Continuous_Input_Point = {0, .R7 = Continuous_Input_Point_R7_29_refs, .R7__count = COUNTOF(Continuous_Input_Point_R7_29_refs), .R4 = &Conversion_Group_storage[1]}}}}},
    {.R1__code = 2, .R1 = {.R1_Continuous_Point = {.R3 = &Point_Scaling_storage[1], .R2__code = 1, .R2 = {.R2_Continuous_Input_Point = {0, .R7 = Continuous_Input_Point_R7_30_refs, .R7__count = COUNTOF(Continuous_Input_Point_R7_30_refs), .R4 = &Conversion_Group_storage[2]}}}}},
    {.R1__code = 0, .R1 = {.R1_Discrete_Point = {.R8__code = 1, .R8 = {.R8_Control_Point = {Memory, ReadWrite}}}}},
    {.R1__code = 0, .R1 = {.R1_Discrete_Point = {.R8__code = 1, .R8 = {.R8_Control_Point = {Memory, ReadWrite}}}}},
    {.R1__code = 0, .R1 = {.R1_Discrete_Point = {.R8__code = 1, .R8 = {.R8_Control_Point = {Memory, ReadWrite}}}}},
    {.R1__code = 1, .R1 = {.R1_Signalling_Point = {.common_ = {1, 0, &Signalling_Point_class}, 0, BothActive, true, 500}}},
    {.R1__code = 1, .R1 = {.R1_Signalling_Point = {.common_ = {2, 0, &Signalling_Point_class}, 0, BothActive, true, 500}}},
    {.R1__code = 1, .R1 = {.R1_Signalling_Point = {.common_ = {3, 0, &Signalling_Point_class}, 0, BothActive, true, 500}}},
    {.R1__code = 1, .R1 = {.R1_Signalling_Point = {.common_ = {4, 0, &Signalling_Point_class}, 0, BothActive, true, 2000}}},
    {.R1__code = 1, .R1 = {.R1_Signalling_Point = {.common_ = {5, 0, &Signalling_Point_class}, 0, BothActive, true, 2000}}}
} ;
/*
 * Initial Instance Storage for, "Point_Scaling"
 */
static struct Point_Scaling Point_Scaling_storage[2] = {
    {1, 1, 0, ~0},
    {1, 1, 0, ~0}
} ;
/*
 * Initial Instance Storage for, "Point_Threshold"
 */
static struct Point_Threshold Point_Threshold_storage[6] = {
    {26, Rising, 2, 2},
    {15, Rising, 2, 2},
    {26, Rising, 1, 2},
    {32, Rising, 2, 2},
    {19, Rising, 2, 2},
    {35, Rising, 1, 2}
} ;
/*
 * Initial Instance Storage for, "Range_Limitation"
 */
static struct Range_Limitation Range_Limitation_storage[9] = {
    {.common_ = {1, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[0], .R7_CIP = &IO_Point_storage[0].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {2, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[1], .R7_CIP = &IO_Point_storage[0].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {3, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[2], .R7_CIP = &IO_Point_storage[0].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {4, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[3], .R7_CIP = &IO_Point_storage[1].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {5, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[4], .R7_CIP = &IO_Point_storage[1].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {6, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[5], .R7_CIP = &IO_Point_storage[1].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {7, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[0], .R7_CIP = &IO_Point_storage[2].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {8, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[1], .R7_CIP = &IO_Point_storage[2].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point},
    {.common_ = {9, 0, &Range_Limitation_class}, 0, 0, .R7_PT = &Point_Threshold_storage[2], .R7_CIP = &IO_Point_storage[2].R1.R1_Continuous_Point.R2.R2_Continuous_Input_Point}
} ;
/*
 * Initial Instance Storage for, "Signal_Converter"
 */
static struct Signal_Converter Signal_Converter_storage[1] = {
    {.common_ = {1, 0, &Signal_Converter_class}, true, .R5 = Signal_Converter_R5_49_refs, .R5__count = COUNTOF(Signal_Converter_R5_49_refs), .R6 = NULL, .assigner = &R6_Assigner_storage[0]}
} ;
/*
 * Initial Instance Storage for, "Conversion_Group"
 */
static struct Conversion_Group Conversion_Group_storage[3] = {
    {.common_ = {1, 0, &Conversion_Group_class}, false, 500, .R4 = Conversion_Group_R4_46_refs, .R4__count = COUNTOF(Conversion_Group_R4_46_refs), .R5 = &Signal_Converter_storage[0]},
    {.common_ = {2, 0, &Conversion_Group_class}, false, 500, .R4 = Conversion_Group_R4_47_refs, .R4__count = COUNTOF(Conversion_Group_R4_47_refs), .R5 = &Signal_Converter_storage[0]},
    {.common_ = {3, 0, &Conversion_Group_class}, false, 500, .R4 = Conversion_Group_R4_48_refs, .R4__count = COUNTOF(Conversion_Group_R4_48_refs), .R5 = &Signal_Converter_storage[0]}
} ;
/*
 * Initial Instance Storage for, "R6_Assigner"
 */
static struct R6_Assigner R6_Assigner_storage[1] = {
    {.common_ = {1, 0, &R6_Assigner_class}, .idclass = &Signal_Converter_storage[0]}
} ;

/*
 * Operation Function Definitions
 */
#define THISCLASS__ Continuous_Input_Point
static void Continuous_Input_Point_updateValue(struct Continuous_Input_Point *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.Continuous_Input_Point.updateValue") ;

    ClassRefVar(Continuous_Point, cpt) = PYCCA_unionSupertype(self, Continuous_Point, R2) ;
    ClassRefVar(Point_Scaling, ps) = cpt->R3 ;
    assert(ps != NULL) ;
    self->Value = InstOp(Point_Scaling, scaleValueIn)(ps, value) ;

    ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(cpt, IO_Point, R1) ;
    ExternalOp(NOTIFY_New_point_value)(
        PYCCA_idOfRef(IO_Point, iop), self->Value) ;

    ClassRefConstSetVar(Range_Limitation, tdset) ;
    PYCCA_forAllRelated(tdset, self, R7) {
        ClassRefVar(Range_Limitation, td) = *tdset ;
        MechEcb np = PYCCA_newEvent(New_point, Range_Limitation, td, self) ;
        PYCCA_eventParam(np, Range_Limitation, New_point, pointValue) =
            self->Value ;
        PYCCA_postEvent(np) ;
    }
}
#undef THISCLASS__
#define THISCLASS__ Continuous_Point
static void Continuous_Point_writePoint(struct Continuous_Point *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.Continuous_Point.writePoint") ;

    assert(PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
            Continuous_Output_Point) ||
        PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
            Continuous_Input_Point)) ;

    if (PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
            Continuous_Output_Point)) {
        ClassRefVar(Point_Scaling, ps) = self->R3 ;
        assert(ps != NULL) ;
        sio_Point_ID pid =
            PYCCA_idOfRef(IO_Point, PYCCA_unionSupertype(self, IO_Point, R1)) ;

        sio_Point_Value scaled = InstOp(Point_Scaling, scaleValueOut)(ps, value) ;
        ExternalOp(DEVICE_Write_reg)(pid, scaled) ;
    }
    /*
     * Writes to Continuous Input Points are silently ignored.
     */
}
#undef THISCLASS__
#define THISCLASS__ Continuous_Point
static sio_Point_Value Continuous_Point_readPoint(struct Continuous_Point *self)
{
    INSTR_FUNC("sio.Continuous_Point.readPoint") ;

    assert(PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
            Continuous_Output_Point) ||
        PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
            Continuous_Input_Point)) ;

    return PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
            Continuous_Input_Point) ?
        PYCCA_unionSubtype(self, R2, Continuous_Input_Point)->Value : 0 ;
}
#undef THISCLASS__
#define THISCLASS__ Control_Point
static sio_Point_Value Control_Point_readPoint(struct Control_Point *self)
{
    INSTR_FUNC("sio.Control_Point.readPoint") ;

    sio_Point_Value value = 0 ;
    if (self->Access != WriteOnly) {
        sio_Point_ID pid =
            PYCCA_idOfRef(IO_Point,
            PYCCA_unionSupertype(PYCCA_unionSupertype(self, Discrete_Point, R8),
                IO_Point, R1)) ;
        value = ExternalOp(DEVICE_Read_reg)(pid) ;
    }

    return value ;
}
#undef THISCLASS__
#define THISCLASS__ Control_Point
static void Control_Point_writePoint(struct Control_Point *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.Control_Point.writePoint") ;

    if (self->Access != ReadOnly) {
        sio_Point_ID pid =
            PYCCA_idOfRef(IO_Point,
            PYCCA_unionSupertype(PYCCA_unionSupertype(self, Discrete_Point, R8),
                IO_Point, R1)) ;
        ExternalOp(DEVICE_Write_reg)(pid, value) ;
    }
}
#undef THISCLASS__
#define THISCLASS__ Discrete_Point
static sio_Point_Value Discrete_Point_readPoint(struct Discrete_Point *self)
{
    INSTR_FUNC("sio.Discrete_Point.readPoint") ;

    assert(PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Packed_Point) ||
            PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Control_Point)) ;

    switch (self->SubCodeMember(R8)) {
    case SubCodeValue(Discrete_Point, R8, Packed_Point):
        return InstOp(Packed_Point, readPoint)(
                PYCCA_unionSubtype(self, R8, Packed_Point)) ;

    case SubCodeValue(Discrete_Point, R8, Control_Point):
        return InstOp(Control_Point, readPoint)(
                PYCCA_unionSubtype(self, R8, Control_Point)) ;

    default:
        return 0 ;
    }
}
#undef THISCLASS__
#define THISCLASS__ Discrete_Point
static void Discrete_Point_writePoint(struct Discrete_Point *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.Discrete_Point.writePoint") ;

    assert(PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Packed_Point) ||
            PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Control_Point)) ;

    switch (self->SubCodeMember(R8)) {
    case SubCodeValue(Discrete_Point, R8, Packed_Point):
        InstOp(Packed_Point, writePoint)(PYCCA_unionSubtype(self, R8,
                Packed_Point), value) ;
        break ;

    case SubCodeValue(Discrete_Point, R8, Control_Point):
        InstOp(Control_Point, writePoint)(PYCCA_unionSubtype(self, R8,
                Control_Point), value) ;
        break ;

    // N.B. no default
    }
}
#undef THISCLASS__
#define THISCLASS__ IO_Point
static void IO_Point_writePoint(struct IO_Point *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.IO_Point.writePoint") ;

    assert(PYCCA_isSubtypeRelated(self, IO_Point, R1, Discrete_Point) ||
            PYCCA_isSubtypeRelated(self, IO_Point, R1, Continuous_Point)) ;

    switch (self->SubCodeMember(R1)) {
    case SubCodeValue(IO_Point, R1, Discrete_Point):
        InstOp(Discrete_Point, writePoint)(
            PYCCA_unionSubtype(self, R1, Discrete_Point), value) ;
        break ;

    case SubCodeValue(IO_Point, R1, Continuous_Point):
        InstOp(Continuous_Point, writePoint)(
            PYCCA_unionSubtype(self, R1, Continuous_Point), value) ;
        break ;

    // N.B. no default
    }
}
#undef THISCLASS__
#define THISCLASS__ IO_Point
static sio_Point_Value IO_Point_readPoint(struct IO_Point *self)
{
    INSTR_FUNC("sio.IO_Point.readPoint") ;

    assert(PYCCA_isSubtypeRelated(self, IO_Point, R1, Discrete_Point) ||
            PYCCA_isSubtypeRelated(self, IO_Point, R1, Continuous_Point)) ;

    switch (self->SubCodeMember(R1)) {
    case SubCodeValue(IO_Point, R1, Discrete_Point):
        return InstOp(Discrete_Point, readPoint)(
                PYCCA_unionSubtype(self, R1, Discrete_Point)) ;

    case SubCodeValue(IO_Point, R1, Signalling_Point):
        return InstOp(Signalling_Point, readPoint)(
                PYCCA_unionSubtype(self, R1, Signalling_Point)) ;

    case SubCodeValue(IO_Point, R1, Continuous_Point):
        return InstOp(Continuous_Point, readPoint)(
                PYCCA_unionSubtype(self, R1, Continuous_Point)) ;

    default:
        return 0 ;
    }
}
#undef THISCLASS__
#define THISCLASS__ Packed_Point
static void Packed_Point_writePoint(struct Packed_Point *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.Packed_Point.writePoint") ;

    sio_Point_Value mask = ((1 << self->Length) - 1) << self->Offset ;
    ClassRefVar(Control_Point, ctpt) = self->R9 ;
    assert(ctpt != NULL) ;
    sio_Point_Value base ;
    switch (ctpt->Memory_model) {
    case Memory:
    default:
        base = InstOp(Control_Point, readPoint)(ctpt) & ~mask ;
        break ;

    case ReadClear:
        base = 0 ;
        break ;

    case ReadClearZero:
        base = ~0 ;
        break ;
    }

    InstOp(Control_Point, writePoint)(ctpt,
            ((value << self->Offset) & mask) | base) ;
}
#undef THISCLASS__
#define THISCLASS__ Packed_Point
static sio_Point_Value Packed_Point_readPoint(struct Packed_Point *self)
{
    INSTR_FUNC("sio.Packed_Point.readPoint") ;

    sio_Point_Value mask = (1 << self->Length) - 1 ;
    ClassRefVar(Control_Point, ctpt) = self->R9 ;
    assert(ctpt != NULL) ;
    sio_Point_Value value = InstOp(Control_Point, readPoint)(ctpt) ;
    return (value >> self->Offset) & mask ;
}
#undef THISCLASS__
#define THISCLASS__ Point_Scaling
static sio_Point_Value Point_Scaling_scaleValueIn(struct Point_Scaling *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.Point_Scaling.scaleValueIn") ;

    /*
     * Convert, rounding to deal with division truncation.
     */
    sio_Point_Value in = ((value * self->Multiplier + self->Divisor / 2) /
            self->Divisor) + self->Intercept ;
    if (in > self->Mask) {
        in = self->Mask ;
    }
    return in ;
}
static sio_Point_Value Point_Scaling_scaleValueOut(struct Point_Scaling *self, sio_Point_Value value)
{
    INSTR_FUNC("sio.Point_Scaling.scaleValueOut") ;

    if (value < self->Intercept) {
        value = self->Intercept ;
    }
    /*
     * Convert, rounding to deal with division truncation.
     */
    sio_Point_Value out = (((value - self->Intercept) * self->Multiplier) +
            self->Divisor / 2) / self->Divisor ;
    if (out > self->Mask) {
        out = self->Mask ;
    }
    return out ;
}
#undef THISCLASS__
#define THISCLASS__ Signalling_Point
static void Signalling_Point_evalSignal(struct Signalling_Point *self)
{
    INSTR_FUNC("sio.Signalling_Point.evalSignal") ;

    sio_Point_ID ptid = PYCCA_idOfRef(IO_Point,
            PYCCA_unionSupertype(self, IO_Point, R1)) ;
    if ((self->Value == 1 && self->Active_high) ||
            (self->Value == 0 && !self->Active_high)) {
        if (self->Trigger != Inactive) {
            ExternalOp(NOTIFY_Signal_point)(ptid, true) ;
        }
    } else {
        if (self->Trigger != Active) {
            ExternalOp(NOTIFY_Signal_point)(ptid, false) ;
        }
    }
    ExternalOp(DEVICE_Enable_signal)(ptid) ;
}
static sio_Point_Value Signalling_Point_readPoint(struct Signalling_Point *self)
{
    INSTR_FUNC("sio.Signalling_Point.readPoint") ;

    sio_Point_ID pid =
        PYCCA_idOfRef(IO_Point, PYCCA_unionSupertype(self, IO_Point, R1)) ;
    return ExternalOp(DEVICE_Read_reg)(pid) ;
}
#undef THISCLASS__

/*
 * Constructor Function Definitions
 */

/*
 * Destructor Function Definitions
 */

/*
 * State Action Function Definitions
 */
#define THISCLASS__ Conversion_Group
static void Conversion_Group_FINISHED(void *const s_, void *const p_)
{
#define THISSTATE__ FINISHED
    INSTR_FUNC("sio.Conversion_Group.FINISHED") ;
    struct Conversion_Group *const self = (struct Conversion_Group *)s_ ;

    PYCCA_cancelDelayedToSelf(Sample) ;
    self->Waiting_for_converter = false ;
#undef THISSTATE__
}
static void Conversion_Group_WAITING_FOR_CONVERSION(void *const s_, void *const p_)
{
#define THISSTATE__ WAITING_FOR_CONVERSION
    INSTR_FUNC("sio.Conversion_Group.WAITING_FOR_CONVERSION") ;
    struct Conversion_Group *const self = (struct Conversion_Group *)s_ ;

    self->Waiting_for_converter = true ;
    ClassRefVar(R6_Assigner, r6asgn) = self->R5->assigner ;
    PYCCA_generate(Group_ready, R6_Assigner, r6asgn, self) ;
#undef THISSTATE__
}
static void Conversion_Group_CONVERSION_COMPLETED(void *const s_, void *const p_)
{
#define THISSTATE__ CONVERSION_COMPLETED
    INSTR_FUNC("sio.Conversion_Group.CONVERSION_COMPLETED") ;
    struct Conversion_Group *const self = (struct Conversion_Group *)s_ ;

    if (self->Period != 0) {
        PYCCA_generateDelayedToSelf(Sample, self->Period) ;
    }
#undef THISSTATE__
}
#undef THISCLASS__
#define THISCLASS__ R6_Assigner
static void R6_Assigner_WAITING_FOR_GROUP(void *const s_, void *const p_)
{
#define THISSTATE__ WAITING_FOR_GROUP
    INSTR_FUNC("sio.R6_Assigner.WAITING_FOR_GROUP") ;
    struct R6_Assigner *const self = (struct R6_Assigner *)s_ ;

    ClassRefVar(Signal_Converter, sc) = self->idclass ;

    ClassRefConstSetVar(Conversion_Group, cgset) ;
    PYCCA_forAllRelated(cgset, sc, R5) {
        ClassRefVar(Conversion_Group, cg) = *cgset ;
        if (cg->Waiting_for_converter) {
            PYCCA_generateToSelf(Group_ready) ;
            return ;
        }
    }
#undef THISSTATE__
}
static void R6_Assigner_WAITING_FOR_CONVERTER(void *const s_, void *const p_)
{
#define THISSTATE__ WAITING_FOR_CONVERTER
    INSTR_FUNC("sio.R6_Assigner.WAITING_FOR_CONVERTER") ;
    struct R6_Assigner *const self = (struct R6_Assigner *)s_ ;

    ClassRefVar(Signal_Converter, sc) = self->idclass ;
    if (sc->Converter_available) {
        PYCCA_generateToSelf(Converter_ready) ;
    }
#undef THISSTATE__
}
static void R6_Assigner_Assigning_Converter(void *const s_, void *const p_)
{
#define THISSTATE__ Assigning_Converter
    INSTR_FUNC("sio.R6_Assigner.Assigning_Converter") ;
    struct R6_Assigner *const self = (struct R6_Assigner *)s_ ;

    ClassRefVar(Signal_Converter, sc) = self->idclass ;
    assert(sc->Converter_available) ;
    ClassRefConstSetVar(Conversion_Group, cgset) ;
    PYCCA_forAllRelated(cgset, sc, R5) {
        ClassRefVar(Conversion_Group, cg) = *cgset ;
        if (cg->Waiting_for_converter) {
            sc->R6 = cg ;

            sc->Converter_available = false ;
            cg->Waiting_for_converter = false ;
            PYCCA_generateToSelf(Converter_assigned) ;
            PYCCA_generate(Converter_assigned, Signal_Converter, sc, self) ;
            return ;
        }
    }
#undef THISSTATE__
}
#undef THISCLASS__
#define THISCLASS__ Range_Limitation
static void Range_Limitation_CHECKING_OUT_OF_RANGE(void *const s_, void *const p_)
{
#define THISSTATE__ CHECKING_OUT_OF_RANGE
    INSTR_FUNC("sio.Range_Limitation.CHECKING_OUT_OF_RANGE") ;
    struct Range_Limitation *const self = (struct Range_Limitation *)s_ ;
    struct Range_Limitation_CHECKING_OUT_OF_RANGE_rcvd_evt {
        sio_Point_Value pointValue ;
    } const *const rcvd_evt = (struct Range_Limitation_CHECKING_OUT_OF_RANGE_rcvd_evt const *)p_ ;

    ClassRefVar(Point_Threshold, pt) = self->R7_PT ;

    bool outRange = pt->Direction == Rising ?
            rcvd_evt->pointValue > pt->Limit :
            rcvd_evt->pointValue <= pt->Limit ;
    if (outRange) {
        if (++self->Over_count >= pt->Over_limit) {
            PYCCA_generateToSelf(Out_of_range) ;
        }
    } else {
        self->Over_count = 0 ;
    }
#undef THISSTATE__
}
static void Range_Limitation_CHECKING_IN_RANGE(void *const s_, void *const p_)
{
#define THISSTATE__ CHECKING_IN_RANGE
    INSTR_FUNC("sio.Range_Limitation.CHECKING_IN_RANGE") ;
    struct Range_Limitation *const self = (struct Range_Limitation *)s_ ;
    struct Range_Limitation_CHECKING_IN_RANGE_rcvd_evt {
        sio_Point_Value pointValue ;
    } const *const rcvd_evt = (struct Range_Limitation_CHECKING_IN_RANGE_rcvd_evt const *)p_ ;

    ClassRefVar(Point_Threshold, pt) = self->R7_PT ;

    bool inRange = pt->Direction == Rising ?
            rcvd_evt->pointValue <= pt->Limit :
            rcvd_evt->pointValue > pt->Limit ;
    if (inRange) {
        if (++self->Under_count >= pt->Under_limit) {
            PYCCA_generateToSelf(In_range) ;
        }
    } else {
        self->Under_count = 0 ;
    }
#undef THISSTATE__
}
#undef THISCLASS__
#define THISCLASS__ Range_Limitation
static void Range_Limitation_IN_RANGE(void *const s_, void *const p_)
{
#define THISSTATE__ IN_RANGE
    INSTR_FUNC("sio.Range_Limitation.IN_RANGE") ;
    struct Range_Limitation *const self = (struct Range_Limitation *)s_ ;

    ClassRefVar(Continuous_Input_Point, cip) = self->R7_CIP ;
    ClassRefVar(Continuous_Point, cp) = PYCCA_unionSupertype(cip,
        Continuous_Point, R2) ;
    ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(cp,
        IO_Point, R1) ;
    ExternalOp(NOTIFY_In_range)(PYCCA_idOfRef(IO_Point, iop),
            PYCCA_idOfRef(Point_Threshold, self->R7_PT)) ;
    self->Over_count = 0 ;
#undef THISSTATE__
}
static void Range_Limitation_OUT_OF_RANGE(void *const s_, void *const p_)
{
#define THISSTATE__ OUT_OF_RANGE
    INSTR_FUNC("sio.Range_Limitation.OUT_OF_RANGE") ;
    struct Range_Limitation *const self = (struct Range_Limitation *)s_ ;

    ClassRefVar(Continuous_Input_Point, cip) = self->R7_CIP ;
    ClassRefVar(Continuous_Point, cp) = PYCCA_unionSupertype(cip,
        Continuous_Point, R2) ;
    ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(cp,
        IO_Point, R1) ;
    ExternalOp(NOTIFY_Out_of_range)(PYCCA_idOfRef(IO_Point, iop),
            PYCCA_idOfRef(Point_Threshold, self->R7_PT)) ;
    self->Under_count = 0 ;
#undef THISSTATE__
}
#undef THISCLASS__
#define THISCLASS__ Signal_Converter
static void Signal_Converter_CONVERSION_COMPLETE(void *const s_, void *const p_)
{
#define THISSTATE__ CONVERSION_COMPLETE
    INSTR_FUNC("sio.Signal_Converter.CONVERSION_COMPLETE") ;
    struct Signal_Converter *const self = (struct Signal_Converter *)s_ ;

    ClassRefVar(Conversion_Group, cg) ;
    cg = self->R6 ;
    assert(cg != NULL) ;
    ClassRefConstSetVar(Continuous_Input_Point, cipset) ;
    PYCCA_forAllRelated(cipset, cg, R4) {
        ClassRefVar(Continuous_Input_Point, cip) = *cipset ;
        ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(
            PYCCA_unionSupertype(cip, Continuous_Point, R2), IO_Point, R1) ;
        sio_Point_Value value = ExternalOp(DEVICE_Read_converted_value)(
                PYCCA_idOfSelf, PYCCA_idOfRef(IO_Point, iop)) ;
        InstOp(Continuous_Input_Point, updateValue)(cip, value) ;
    }
    PYCCA_generate(Conversion_done, Conversion_Group, cg, self) ;

    self->R6 = NULL ;

    self->Converter_available = true ;
    ClassRefVar(R6_Assigner, r6asgn) = self->assigner ;
    PYCCA_generate(Converter_ready, R6_Assigner, r6asgn, self) ;
#undef THISSTATE__
}
static void Signal_Converter_CONVERTING(void *const s_, void *const p_)
{
#define THISSTATE__ CONVERTING
    INSTR_FUNC("sio.Signal_Converter.CONVERTING") ;
    struct Signal_Converter *const self = (struct Signal_Converter *)s_ ;

    ClassRefVar(Conversion_Group, cg) = self->R6 ;
    assert(cg != NULL) ;
    ExternalOp(DEVICE_Convert_group)(PYCCA_idOfSelf,
        PYCCA_idOfRef(Conversion_Group, cg)) ;
#undef THISSTATE__
}
#undef THISCLASS__
#define THISCLASS__ Signalling_Point
static void Signalling_Point_OFF(void *const s_, void *const p_)
{
#define THISSTATE__ OFF
    INSTR_FUNC("sio.Signalling_Point.OFF") ;
    struct Signalling_Point *const self = (struct Signalling_Point *)s_ ;

    PYCCA_cancelDelayedToSelf(Confirm) ;
    ExternalOp(DEVICE_Disable_signal)(
            PYCCA_idOfRef(IO_Point, PYCCA_unionSupertype(self, IO_Point, R1))) ;
#undef THISSTATE__
}
static void Signalling_Point_ON(void *const s_, void *const p_)
{
#define THISSTATE__ ON
    INSTR_FUNC("sio.Signalling_Point.ON") ;
    struct Signalling_Point *const self = (struct Signalling_Point *)s_ ;

    sio_Point_ID ptid = PYCCA_idOfRef(IO_Point,
            PYCCA_unionSupertype(self, IO_Point, R1)) ;
    self->Value = ExternalOp(DEVICE_Read_reg)(ptid) ;
    ThisClassInstOp(evalSignal)(self) ;
#undef THISSTATE__
}
static void Signalling_Point_DEBOUNCING(void *const s_, void *const p_)
{
#define THISSTATE__ DEBOUNCING
    INSTR_FUNC("sio.Signalling_Point.DEBOUNCING") ;
    struct Signalling_Point *const self = (struct Signalling_Point *)s_ ;

    PYCCA_generateDelayedToSelf(Confirm, self->Debounce_time) ;
#undef THISSTATE__
}
static void Signalling_Point_CONFIRMING(void *const s_, void *const p_)
{
#define THISSTATE__ CONFIRMING
    INSTR_FUNC("sio.Signalling_Point.CONFIRMING") ;
    struct Signalling_Point *const self = (struct Signalling_Point *)s_ ;

    sio_Point_ID ptid = PYCCA_idOfRef(IO_Point,
            PYCCA_unionSupertype(self, IO_Point, R1)) ;
    sio_Point_Value status = ExternalOp(DEVICE_Read_reg)(ptid) ;
    if (status != self->Value) {
        self->Value = status ;
        ThisClassInstOp(evalSignal)(self) ;
    }
#undef THISSTATE__
}
#undef THISCLASS__

/*
 * Domain Operation Definitions
 */
sio_Point_Value sio_Read_point(sio_Point_ID pid)
{
    INSTR_FUNC("sio.Read_point") ;

    PYCCA_checkId(IO_Point, pid) ;
    ClassRefVar(IO_Point, iop) = PYCCA_refOfId(IO_Point, pid) ;
    return InstOp(IO_Point, readPoint)(iop) ;
}
void sio_Write_point(sio_Point_ID pid, sio_Point_Value value)
{
    INSTR_FUNC("sio.Write_point") ;

    PYCCA_checkId(IO_Point, pid) ;
    ClassRefVar(IO_Point, iop) = PYCCA_refOfId(IO_Point, pid) ;
    InstOp(IO_Point, writePoint)(iop, value) ;
}
void sio_init(void)
{
    INSTR_FUNC("sio.init") ;

    ClassRefVar(IO_Point, iopt) ;
    PYCCA_forAllInst(iopt, IO_Point) {
        if (iopt->SubCodeMember(R1) ==
                SubCodeValue(IO_Point, R1, Signalling_Point)) {
            ClassRefVar(Signalling_Point, spt) =
                    PYCCA_unionSubtype(iopt, R1, Signalling_Point) ;
            PYCCA_generate(On, Signalling_Point, spt, NULL) ;
        }
    }
}

/*
 * Definition of Function to Construct Initial Instances
 */


/*
 * implementation epilog code
 */



