# DO NOT EDIT THIS FILE!
# THIS FILE IS GENERATED FROM THE SOURCE OF A LITERATE PROGRAM.
# YOU MUST EDIT THE ORIGINAL SOURCE TO MODIFY THIS FILE.
#*++
# Copyright 2017 by Leon Starr, Andrew Mangogna and Stephen Mellor
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Project:
#   Models to Code Book
#
# Module:
#   Signal I/O Domain pycca file
#*--

domain sio
    interface prolog {
    typedef uint8_t sio_Point_ID ;
    typedef int32_t sio_Point_Value ;
    typedef uint8_t sio_Converter_ID ;
    typedef uint8_t sio_Group_ID ;
    typedef uint8_t sio_Threshold_ID ;
    }
    interface epilog {
    }
    domain operation
    Read_point(
        sio_Point_ID pid) : (sio_Point_Value)
    {
        PYCCA_checkId(IO_Point, pid) ;
        ClassRefVar(IO_Point, iop) = PYCCA_refOfId(IO_Point, pid) ;
        return InstOp(IO_Point, readPoint)(iop) ;
    }
    domain operation
    Write_point(
        sio_Point_ID pid,
        sio_Point_Value value)
    {
        PYCCA_checkId(IO_Point, pid) ;
        ClassRefVar(IO_Point, iop) = PYCCA_refOfId(IO_Point, pid) ;
        InstOp(IO_Point, writePoint)(iop, value) ;
    }
    domain operation
    init()
    {
        ClassRefVar(IO_Point, iopt) ;
        PYCCA_forAllInst(iopt, IO_Point) {
            if (iopt->SubCodeMember(R1) ==
                    SubCodeValue(IO_Point, R1, Signalling_Point)) {
                ClassRefVar(Signalling_Point, spt) =
                        PYCCA_unionSubtype(iopt, R1, Signalling_Point) ;
                PYCCA_generate(On, Signalling_Point, spt, NULL) ;
            }
        }
    }
    external operation
    NOTIFY_New_point_value(
        sio_Point_ID point,
        sio_Point_Value value)
    {
    }
    external operation
    NOTIFY_In_range(
        sio_Point_ID point,
        sio_Threshold_ID threshold)
    {
    }
    external operation
    NOTIFY_Out_of_range(
        sio_Point_ID point,
        sio_Threshold_ID threshold)
    {
    }
    external operation
    NOTIFY_Signal_point(
        sio_Point_ID point,
        bool isActive)
    {
    }
    external operation
    DEVICE_Convert_group(
        sio_Converter_ID converter,
        sio_Group_ID group)
    {
    }
    external operation
    DEVICE_Read_converted_value(
        sio_Converter_ID converter,
        sio_Point_ID point) : (sio_Point_Value)
    {
    }
    external operation
    DEVICE_Write_reg(
        sio_Point_ID pid,
        sio_Point_Value value)
    {
    }
    external operation
    DEVICE_Read_reg(
        sio_Point_ID pid) : (sio_Point_Value)
    {
        return 0 ;
    }
    external operation
    DEVICE_Enable_signal(
        sio_Point_ID pid)
    {
    }
    external operation
    DEVICE_Disable_signal(
        sio_Point_ID pid)
    {
    }
    class IO_Point
        population static
        subtype R1 union
            Discrete_Point
            Signalling_Point
            Continuous_Point
        end
        instance operation
        readPoint() : (sio_Point_Value)
        {
            assert(PYCCA_isSubtypeRelated(self, IO_Point, R1, Discrete_Point) ||
                    PYCCA_isSubtypeRelated(self, IO_Point, R1, Continuous_Point)) ;
        
            switch (self->SubCodeMember(R1)) {
            case SubCodeValue(IO_Point, R1, Discrete_Point):
                return InstOp(Discrete_Point, readPoint)(
                        PYCCA_unionSubtype(self, R1, Discrete_Point)) ;
        
            case SubCodeValue(IO_Point, R1, Signalling_Point):
                return InstOp(Signalling_Point, readPoint)(
                        PYCCA_unionSubtype(self, R1, Signalling_Point)) ;
        
            case SubCodeValue(IO_Point, R1, Continuous_Point):
                return InstOp(Continuous_Point, readPoint)(
                        PYCCA_unionSubtype(self, R1, Continuous_Point)) ;
        
            default:
                return 0 ;
            }
        }
        instance operation
        writePoint(
            sio_Point_Value value)
        {
            assert(PYCCA_isSubtypeRelated(self, IO_Point, R1, Discrete_Point) ||
                    PYCCA_isSubtypeRelated(self, IO_Point, R1, Continuous_Point)) ;
        
            switch (self->SubCodeMember(R1)) {
            case SubCodeValue(IO_Point, R1, Discrete_Point):
                InstOp(Discrete_Point, writePoint)(
                    PYCCA_unionSubtype(self, R1, Discrete_Point), value) ;
                break ;
        
            case SubCodeValue(IO_Point, R1, Continuous_Point):
                InstOp(Continuous_Point, writePoint)(
                    PYCCA_unionSubtype(self, R1, Continuous_Point), value) ;
                break ;
        
            // N.B. no default
            }
        }
    end
    class Discrete_Point
        population static
        subtype R8 union
            Packed_Point
            Control_Point
        end
        instance operation
        readPoint() : (sio_Point_Value)
        {
            assert(PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Packed_Point) ||
                    PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Control_Point)) ;
        
            switch (self->SubCodeMember(R8)) {
            case SubCodeValue(Discrete_Point, R8, Packed_Point):
                return InstOp(Packed_Point, readPoint)(
                        PYCCA_unionSubtype(self, R8, Packed_Point)) ;
        
            case SubCodeValue(Discrete_Point, R8, Control_Point):
                return InstOp(Control_Point, readPoint)(
                        PYCCA_unionSubtype(self, R8, Control_Point)) ;
        
            default:
                return 0 ;
            }
        }
        instance operation
        writePoint(
            sio_Point_Value value)
        {
            assert(PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Packed_Point) ||
                    PYCCA_isSubtypeRelated(self, Discrete_Point, R8, Control_Point)) ;
        
            switch (self->SubCodeMember(R8)) {
            case SubCodeValue(Discrete_Point, R8, Packed_Point):
                InstOp(Packed_Point, writePoint)(PYCCA_unionSubtype(self, R8,
                        Packed_Point), value) ;
                break ;
        
            case SubCodeValue(Discrete_Point, R8, Control_Point):
                InstOp(Control_Point, writePoint)(PYCCA_unionSubtype(self, R8,
                        Control_Point), value) ;
                break ;
        
            // N.B. no default
            }
        }
    end
    class Signalling_Point
        population static
        attribute (sio_Point_Value Value) default {0}
        attribute (Edge_Type Trigger)
        attribute (bool Active_high)
        attribute (Msec Debounce_time)
        instance operation
        evalSignal()
        {
            sio_Point_ID ptid = PYCCA_idOfRef(IO_Point,
                    PYCCA_unionSupertype(self, IO_Point, R1)) ;
            if ((self->Value == 1 && self->Active_high) ||
                    (self->Value == 0 && !self->Active_high)) {
                if (self->Trigger != Inactive) {
                    ExternalOp(NOTIFY_Signal_point)(ptid, true) ;
                }
            } else {
                if (self->Trigger != Active) {
                    ExternalOp(NOTIFY_Signal_point)(ptid, false) ;
                }
            }
            ExternalOp(DEVICE_Enable_signal)(ptid) ;
        }
        instance operation
        readPoint() : (sio_Point_Value)
        {
            sio_Point_ID pid =
                PYCCA_idOfRef(IO_Point, PYCCA_unionSupertype(self, IO_Point, R1)) ;
            return ExternalOp(DEVICE_Read_reg)(pid) ;
        }
        machine
            initial state OFF
            default transition IG
            
            transition OFF - On -> ON
            transition OFF - Confirm -> CH
            
            transition ON - Off -> OFF
            transition ON - Confirm -> CH
            transition ON - Trigger -> DEBOUNCING
            
            transition DEBOUNCING - Off -> OFF
            transition DEBOUNCING - Confirm -> CONFIRMING
            
            transition CONFIRMING - Off -> OFF
            transition CONFIRMING - Confirm -> CH
            transition CONFIRMING - Trigger -> DEBOUNCING
            state OFF() {
                PYCCA_cancelDelayedToSelf(Confirm) ;
                ExternalOp(DEVICE_Disable_signal)(
                        PYCCA_idOfRef(IO_Point, PYCCA_unionSupertype(self, IO_Point, R1))) ;
            }
            state ON() {
                sio_Point_ID ptid = PYCCA_idOfRef(IO_Point,
                        PYCCA_unionSupertype(self, IO_Point, R1)) ;
                self->Value = ExternalOp(DEVICE_Read_reg)(ptid) ;
                ThisClassInstOp(evalSignal)(self) ;
            }
            state DEBOUNCING() {
                PYCCA_generateDelayedToSelf(Confirm, self->Debounce_time) ;
            }
            state CONFIRMING() {
                sio_Point_ID ptid = PYCCA_idOfRef(IO_Point,
                        PYCCA_unionSupertype(self, IO_Point, R1)) ;
                sio_Point_Value status = ExternalOp(DEVICE_Read_reg)(ptid) ;
                if (status != self->Value) {
                    self->Value = status ;
                    ThisClassInstOp(evalSignal)(self) ;
                }
            }
        end
    end
    class Continuous_Point
        population static
        reference R3 -> Point_Scaling
        subtype R2 union
            Continuous_Output_Point
            Continuous_Input_Point
        end
        instance operation
        readPoint() : (sio_Point_Value)
        {
            assert(PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
                    Continuous_Output_Point) ||
                PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
                    Continuous_Input_Point)) ;
        
            return PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
                    Continuous_Input_Point) ?
                PYCCA_unionSubtype(self, R2, Continuous_Input_Point)->Value : 0 ;
        }
        instance operation
        writePoint(
            sio_Point_Value value)
        {
            assert(PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
                    Continuous_Output_Point) ||
                PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
                    Continuous_Input_Point)) ;
        
            if (PYCCA_isSubtypeRelated(self, Continuous_Point, R2,
                    Continuous_Output_Point)) {
                ClassRefVar(Point_Scaling, ps) = self->R3 ;
                assert(ps != NULL) ;
                sio_Point_ID pid =
                    PYCCA_idOfRef(IO_Point, PYCCA_unionSupertype(self, IO_Point, R1)) ;
        
                sio_Point_Value scaled = InstOp(Point_Scaling, scaleValueOut)(ps, value) ;
                ExternalOp(DEVICE_Write_reg)(pid, scaled) ;
            }
            /*
             * Writes to Continuous Input Points are silently ignored.
             */
        }
    end
    class Packed_Point
        population static
        attribute (Bit_Count Length)
        attribute (Bit_Offset Offset)
        reference R9 -> Control_Point
        instance operation
        readPoint() : (sio_Point_Value)
        {
            sio_Point_Value mask = (1 << self->Length) - 1 ;
            ClassRefVar(Control_Point, ctpt) = self->R9 ;
            assert(ctpt != NULL) ;
            sio_Point_Value value = InstOp(Control_Point, readPoint)(ctpt) ;
            return (value >> self->Offset) & mask ;
        }
        instance operation
        writePoint(
            sio_Point_Value value)
        {
            sio_Point_Value mask = ((1 << self->Length) - 1) << self->Offset ;
            ClassRefVar(Control_Point, ctpt) = self->R9 ;
            assert(ctpt != NULL) ;
            sio_Point_Value base ;
            switch (ctpt->Memory_model) {
            case Memory:
            default:
                base = InstOp(Control_Point, readPoint)(ctpt) & ~mask ;
                break ;
        
            case ReadClear:
                base = 0 ;
                break ;
        
            case ReadClearZero:
                base = ~0 ;
                break ;
            }
        
            InstOp(Control_Point, writePoint)(ctpt,
                    ((value << self->Offset) & mask) | base) ;
        }
    end
    class Control_Point
        population static
        attribute (Memory_Type Memory_model)
        attribute (Access_Type Access)
        instance operation
        readPoint() : (sio_Point_Value)
        {
            sio_Point_Value value = 0 ;
            if (self->Access != WriteOnly) {
                sio_Point_ID pid =
                    PYCCA_idOfRef(IO_Point,
                    PYCCA_unionSupertype(PYCCA_unionSupertype(self, Discrete_Point, R8),
                        IO_Point, R1)) ;
                value = ExternalOp(DEVICE_Read_reg)(pid) ;
            }
        
            return value ;
        }
        instance operation
        writePoint(
            sio_Point_Value value)
        {
            if (self->Access != ReadOnly) {
                sio_Point_ID pid =
                    PYCCA_idOfRef(IO_Point,
                    PYCCA_unionSupertype(PYCCA_unionSupertype(self, Discrete_Point, R8),
                        IO_Point, R1)) ;
                ExternalOp(DEVICE_Write_reg)(pid, value) ;
            }
        }
    end
    class Continuous_Output_Point
        population static
    end
    class Continuous_Input_Point
        population static
        attribute (sio_Point_Value Value) default {0}
        reference R7 ->>c Range_Limitation
        reference R4 -> Conversion_Group
        
        instance operation
        updateValue(
            sio_Point_Value value)
        {
            ClassRefVar(Continuous_Point, cpt) = PYCCA_unionSupertype(self, Continuous_Point, R2) ;
            ClassRefVar(Point_Scaling, ps) = cpt->R3 ;
            assert(ps != NULL) ;
            self->Value = InstOp(Point_Scaling, scaleValueIn)(ps, value) ;
        
            ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(cpt, IO_Point, R1) ;
            ExternalOp(NOTIFY_New_point_value)(
                PYCCA_idOfRef(IO_Point, iop), self->Value) ;
        
            ClassRefConstSetVar(Range_Limitation, tdset) ;
            PYCCA_forAllRelated(tdset, self, R7) {
                ClassRefVar(Range_Limitation, td) = *tdset ;
                MechEcb np = PYCCA_newEvent(New_point, Range_Limitation, td, self) ;
                PYCCA_eventParam(np, Range_Limitation, New_point, pointValue) = value ;
                PYCCA_postEvent(np) ;
            }
        }
    end
    class Point_Scaling
        population static
        attribute (sio_Point_Value Multiplier)
        attribute (sio_Point_Value Divisor)
        attribute (sio_Point_Value Intercept)
        attribute (Point_Value_Mask Mask)
        instance operation
        scaleValueIn(
            sio_Point_Value value) : (sio_Point_Value)
        {
            /*
             * Convert, rounding to deal with division truncation.
             */
            sio_Point_Value in = ((value * self->Multiplier + self->Divisor / 2) /
                    self->Divisor) + self->Intercept ;
            if (in > self->Mask) {
                in = self->Mask ;
            }
            return in ;
        }
        instance operation
        scaleValueOut(
            sio_Point_Value value) : (sio_Point_Value)
        {
            if (value < self->Intercept) {
                value = self->Intercept ;
            }
            /*
             * Convert, rounding to deal with division truncation.
             */
            sio_Point_Value out = (((value - self->Intercept) * self->Multiplier) +
                    self->Divisor / 2) / self->Divisor ;
            if (out > self->Mask) {
                out = self->Mask ;
            }
            return out ;
        }
    end
    class Point_Threshold
        population static
        attribute (sio_Point_Value Limit)
        attribute (Excursion_Direction Direction)
        attribute (Count Over_limit)
        attribute (Count Under_limit)
    end
    class Range_Limitation
        population static
        attribute (Count Over_count) default {0}
        attribute (Count Under_count) default {0}
        reference R7_PT -> Point_Threshold
        reference R7_CIP -> Continuous_Input_Point
        
        machine
            initial state IN_RANGE
            default transition CH
            
            transition IN_RANGE - New_point -> CHECKING_OUT_OF_RANGE
            
            transition CHECKING_OUT_OF_RANGE - New_point -> CHECKING_OUT_OF_RANGE
            transition CHECKING_OUT_OF_RANGE - Out_of_range -> OUT_OF_RANGE
            
            transition OUT_OF_RANGE - New_point -> CHECKING_IN_RANGE
            
            transition CHECKING_IN_RANGE - New_point -> CHECKING_IN_RANGE
            transition CHECKING_IN_RANGE - In_range -> IN_RANGE
            state IN_RANGE() {
                ClassRefVar(Continuous_Input_Point, cip) = self->R7_CIP ;
                ClassRefVar(Continuous_Point, cp) = PYCCA_unionSupertype(cip,
                    Continuous_Point, R2) ;
                ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(cp,
                    IO_Point, R1) ;
                ExternalOp(NOTIFY_In_range)(PYCCA_idOfRef(IO_Point, iop),
                        PYCCA_idOfRef(Point_Threshold, self->R7_PT)) ;
                self->Over_count = 0 ;
            }
            state CHECKING_OUT_OF_RANGE(
                sio_Point_Value pointValue) {
                ClassRefVar(Point_Threshold, pt) = self->R7_PT ;
            
                bool outRange = pt->Direction == Rising ?
                        rcvd_evt->pointValue > pt->Limit :
                        rcvd_evt->pointValue <= pt->Limit ;
                if (outRange) {
                    if (++self->Over_count >= pt->Over_limit) {
                        PYCCA_generateToSelf(Out_of_range) ;
                    }
                } else {
                    self->Over_count = 0 ;
                }
            }
            state OUT_OF_RANGE() {
                ClassRefVar(Continuous_Input_Point, cip) = self->R7_CIP ;
                ClassRefVar(Continuous_Point, cp) = PYCCA_unionSupertype(cip,
                    Continuous_Point, R2) ;
                ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(cp,
                    IO_Point, R1) ;
                ExternalOp(NOTIFY_Out_of_range)(PYCCA_idOfRef(IO_Point, iop),
                        PYCCA_idOfRef(Point_Threshold, self->R7_PT)) ;
                self->Under_count = 0 ;
            }
            state CHECKING_IN_RANGE(
                sio_Point_Value pointValue) {
                ClassRefVar(Point_Threshold, pt) = self->R7_PT ;
            
                bool inRange = pt->Direction == Rising ?
                        rcvd_evt->pointValue <= pt->Limit :
                        rcvd_evt->pointValue > pt->Limit ;
                if (inRange) {
                    if (++self->Under_count >= pt->Under_limit) {
                        PYCCA_generateToSelf(In_range) ;
                    }
                } else {
                    self->Under_count = 0 ;
                }
            }
        end
    end
    class Signal_Converter
        population static
        attribute (bool Converter_available) default {true}
        reference R5 ->>c Conversion_Group
        reference R6 -> Conversion_Group
        reference assigner -> R6_Assigner
        machine
            initial state CONVERSION_COMPLETE
            default transition CH
            
            transition CONVERSION_COMPLETE - Converter_assigned -> CONVERTING
            
            transition CONVERTING - Conversion_done -> CONVERSION_COMPLETE
            state CONVERSION_COMPLETE () {
                ClassRefVar(Conversion_Group, cg) ;
                cg = self->R6 ;
                assert(cg != NULL) ;
                ClassRefConstSetVar(Continuous_Input_Point, cipset) ;
                PYCCA_forAllRelated(cipset, cg, R4) {
                    ClassRefVar(Continuous_Input_Point, cip) = *cipset ;
                    ClassRefVar(IO_Point, iop) = PYCCA_unionSupertype(
                        PYCCA_unionSupertype(cip, Continuous_Point, R2), IO_Point, R1) ;
                    sio_Point_Value value = ExternalOp(DEVICE_Read_converted_value)(
                            PYCCA_idOfSelf, PYCCA_idOfRef(IO_Point, iop)) ;
                    InstOp(Continuous_Input_Point, updateValue)(cip, value) ;
                }
                PYCCA_generate(Conversion_done, Conversion_Group, cg, self) ;
            
                self->R6 = NULL ;
            
                self->Converter_available = true ;
                ClassRefVar(R6_Assigner, r6asgn) = self->assigner ;
                PYCCA_generate(Converter_ready, R6_Assigner, r6asgn, self) ;
            }
            state CONVERTING () {
                ClassRefVar(Conversion_Group, cg) = self->R6 ;
                assert(cg != NULL) ;
                ExternalOp(DEVICE_Convert_group)(PYCCA_idOfSelf,
                    PYCCA_idOfRef(Conversion_Group, cg)) ;
            }
        end
    end
    class Conversion_Group
        population static
        attribute (bool Waiting_for_converter) default {false}
        attribute (Msec Period)
        reference R4 ->>c Continuous_Input_Point
        reference R5 -> Signal_Converter
        
        machine
            initial state FINISHED
            default transition CH
            
            transition FINISHED - Sample -> WAITING_FOR_CONVERSION
            transition FINISHED - Stop -> IG
            transition FINISHED - Conversion_done -> IG
            
            transition WAITING_FOR_CONVERSION - Sample -> WAITING_FOR_CONVERSION
            transition WAITING_FOR_CONVERSION - Stop -> FINISHED
            transition WAITING_FOR_CONVERSION - Conversion_done -> CONVERSION_COMPLETED
            
            transition CONVERSION_COMPLETED - Sample -> WAITING_FOR_CONVERSION
            transition CONVERSION_COMPLETED - Stop -> FINISHED
            state FINISHED() {
                PYCCA_cancelDelayedToSelf(Sample) ;
                self->Waiting_for_converter = false ;
            }
            state WAITING_FOR_CONVERSION() {
                self->Waiting_for_converter = true ;
                ClassRefVar(R6_Assigner, r6asgn) = self->R5->assigner ;
                PYCCA_generate(Group_ready, R6_Assigner, r6asgn, self) ;
            }
            state CONVERSION_COMPLETED() {
                if (self->Period != 0) {
                    PYCCA_generateDelayedToSelf(Sample, self->Period) ;
                }
            }
        end
    end
    class R6_Assigner
        reference idclass -> Signal_Converter
        machine
            default transition CH
            initial state WAITING_FOR_GROUP
            
            transition WAITING_FOR_GROUP - Group_ready -> WAITING_FOR_CONVERTER
            transition WAITING_FOR_GROUP - Converter_ready -> IG
            
            transition WAITING_FOR_CONVERTER - Group_ready -> IG
            transition WAITING_FOR_CONVERTER - Converter_ready -> Assigning_Converter
            
            transition Assigning_Converter - Group_ready -> IG
            transition Assigning_Converter - Converter_ready -> IG
            transition Assigning_Converter - Converter_assigned -> WAITING_FOR_GROUP
            state WAITING_FOR_GROUP () {
                ClassRefVar(Signal_Converter, sc) = self->idclass ;
            
                ClassRefConstSetVar(Conversion_Group, cgset) ;
                PYCCA_forAllRelated(cgset, sc, R5) {
                    ClassRefVar(Conversion_Group, cg) = *cgset ;
                    if (cg->Waiting_for_converter) {
                        PYCCA_generateToSelf(Group_ready) ;
                        return ;
                    }
                }
            }
            state WAITING_FOR_CONVERTER () {
                ClassRefVar(Signal_Converter, sc) = self->idclass ;
                if (sc->Converter_available) {
                    PYCCA_generateToSelf(Converter_ready) ;
                }
            }
            state Assigning_Converter () {
                ClassRefVar(Signal_Converter, sc) = self->idclass ;
                assert(sc->Converter_available) ;
                ClassRefConstSetVar(Conversion_Group, cgset) ;
                PYCCA_forAllRelated(cgset, sc, R5) {
                    ClassRefVar(Conversion_Group, cg) = *cgset ;
                    if (cg->Waiting_for_converter) {
                        sc->R6 = cg ;
            
                        sc->Converter_available = false ;
                        cg->Waiting_for_converter = false ;
                        PYCCA_generateToSelf(Converter_assigned) ;
                        PYCCA_generate(Converter_assigned, Signal_Converter, sc, self) ;
                        return ;
                    }
                }
            }
        end
    end
    table IO_Point
        R1
    @iop1
        -> Continuous_Point.iop1
    @iop2
        -> Continuous_Point.iop2
    @iop3
        -> Continuous_Point.iop3
    @iop4
        -> Discrete_Point.iop4
    @iop5
        -> Discrete_Point.iop5
    @iop6
        -> Discrete_Point.iop6
    @iop7
        -> Signalling_Point.iop7
    @iop8
        -> Signalling_Point.iop8
    @iop9
        -> Signalling_Point.iop9
    @iop10
        -> Signalling_Point.iop10
    @iop11
        -> Signalling_Point.iop11
    end
    table Discrete_Point
        R8
    @iop4
        -> Control_Point.iop4
    @iop5
        -> Control_Point.iop5
    @iop6
        -> Control_Point.iop6
    end
    table Signalling_Point
        (Edge_Type Trigger)
        (bool Active_high)
        (Msec Debounce_time)
    @iop7
        {BothActive}    {true}      {500}
    @iop8
        {BothActive}    {true}      {500}
    @iop9
        {BothActive}    {true}      {500}
    @iop10
        {BothActive}    {true}      {2000}
    @iop11
        {BothActive}    {true}      {2000}
    end
    table Continuous_Point
        R2
        R3
    @iop1
        -> Continuous_Input_Point.iop1
        -> ix77b_pres_scale
    @iop2
        -> Continuous_Input_Point.iop2
        -> ihn4_pres_scale
    @iop3
        -> Continuous_Input_Point.iop3
        -> ix77b_pres_scale
    end
    table Point_Scaling
        (sio_Point_Value Multiplier)
        (sio_Point_Value Divisor)
        (sio_Point_Value Intercept)
        (Point_Value_Mask Mask)
    @ihn4_pres_scale
        {1} {1} {0} {~0}
    @ix77b_pres_scale
        {1} {1} {0} {~0}
    end
    table Control_Point
        (Memory_Type Memory_model)
        (Access_Type Access)
    @iop4
        {Memory} {ReadWrite}
    @iop5
        {Memory} {ReadWrite}
    @iop6
        {Memory} {ReadWrite}
    end
    table Continuous_Input_Point
        R4
        R7
    @iop1
        -> inj1_cg
        ->>
            above_disp_iop1
            above_inj_iop1
            max_pres_iop1
        end
    @iop2
        -> inj2_cg
        ->>
            above_disp_iop2
            above_inj_iop2
            max_pres_iop2
        end
    @iop3
        -> inj3_cg
        ->>
            above_disp_iop3
            above_inj_iop3
            max_pres_iop3
        end
    end
    table Point_Threshold
        (sio_Point_Value Limit)
        (Excursion_Direction Direction)
        (Count Over_limit)
        (Count Under_limit)
    # IX77B design
    @ix77b_above_disp
        {26}    {Rising}    {2}     {2}
    @ix77b_above_inj
        {15}    {Rising}    {2}     {2}
    @ix77b_max_pres
        {26}    {Rising}    {1}     {2}
    
    # IHN4 design
    @ihn4_above_disp
        {32}    {Rising}    {2}     {2}
    @ihn4_above_inj
        {19}    {Rising}    {2}     {2}
    @ihn4_max_pres
        {35}    {Rising}    {1}     {2}
    end
    table Range_Limitation
        R7_PT
        R7_CIP
    @above_disp_iop1
        -> ix77b_above_disp
        -> iop1
    @above_inj_iop1
        -> ix77b_above_inj
        -> iop1
    @max_pres_iop1
        -> ix77b_max_pres
        -> iop1
    @above_disp_iop2
        -> ihn4_above_disp
        -> iop2
    @above_inj_iop2
        -> ihn4_above_inj
        -> iop2
    @max_pres_iop2
        -> ihn4_max_pres
        -> iop2
    @above_disp_iop3
        -> ix77b_above_disp
        -> iop3
    @above_inj_iop3
        -> ix77b_above_inj
        -> iop3
    @max_pres_iop3
        -> ix77b_max_pres
        -> iop3
    end
    table Conversion_Group
        (Msec Period)
        R4
        R5
    @inj1_cg
        {500}   ->> iop1 end   -> cvt1
    @inj2_cg
        {500}   ->> iop2 end   -> cvt1
    @inj3_cg
        {500}   ->> iop3 end   -> cvt1
    end
    instance Signal_Converter@cvt1
        R5 ->>
            inj1_cg
            inj2_cg
            inj3_cg
        end
        assigner -> r6asgn1
    end
    instance R6_Assigner@r6asgn1
        idclass -> cvt1
    end
    implementation prolog {
    #include <assert.h>
    #include "sio.h"
    typedef uint32_t Point_Value_Mask ;
    typedef int Count ;
    typedef uint32_t Msec ;
    typedef enum {ReadWrite, ReadOnly, WriteOnly} Access_Type ;
    typedef enum {Memory, ReadClear, ReadClearZero} Memory_Type ;
    typedef enum {Inactive, Active, BothActive} Edge_Type ;
    typedef uint8_t Bit_Count ;
    typedef uint8_t Bit_Offset ;
    typedef enum {Rising, Falling} Excursion_Direction ;
    }
    implementation epilog {
    }
end
