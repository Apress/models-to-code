/*
# DO NOT EDIT THIS FILE!
# THIS FILE IS GENERATED FROM THE SOURCE OF A LITERATE PROGRAM.
# YOU MUST EDIT THE ORIGINAL SOURCE TO MODIFY THIS FILE.
#*++
# Copyright 2017 by Leon Starr, Andrew Mangogna and Stephen Mellor
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Project:
#   Models to Code Book
#
# Module:
#   Signal I/O External Operations Stubs
#*--
*/

#include <stdbool.h>
#include <inttypes.h>
#include <stddef.h>
#include <assert.h>
#include "pycca_portal.h"
#include "sio.h"
#ifdef TACK
#   include "harness.h"
#endif /* TACK */

#ifndef COUNTOF
#define COUNTOF(a)  (sizeof(a) / sizeof(a[0]))
#endif /* COUNTOF */

void
eop_sio_DEVICE_Convert_group(
    sio_Converter_ID converter,
    sio_Group_ID group)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain sio eop DEVICE_Convert_group "
            "parameters {converter %" PRIu8 " group %" PRIu8 "}",
            converter, group) ;
#       endif /* TACK */

    assert(converter < SIO_SIGNAL_CONVERTER_INST_COUNT) ;
    int pcode = pycca_generate_delayed_event(&sio_portal,
        SIO_SIGNAL_CONVERTER_CLASS_ID,
        converter,
        NormalEvent,
        SIO_SIGNAL_CONVERTER_CONVERSION_DONE_EVENT_ID,
        NULL,
        10) ;
    assert(pcode == 0) ;
    (void)pcode ;
}
typedef struct {
    int valueIndex ;
    int numValues ;
    sio_Point_Value *values ;
} ValueStore ;
static sio_Point_Value
vs_nextValue(
    ValueStore *vs)
{
    if (vs->numValues <= 0) {
        return 0 ;
    }

    sio_Point_Value cval = vs->values[vs->valueIndex] ;
    if (++vs->valueIndex >= vs->numValues) {
        vs->valueIndex = 0 ;
    }

    return cval ;
}
static sio_Point_Value inj1PresValues[] = {20, 21, 22, 26, 27, 16, 15, 14} ;
static sio_Point_Value inj2PresValues[] = {20, 21, 22, 26, 27, 23, 19, 18} ;
static sio_Point_Value inj3PresValues[] = {20, 21, 22, 26, 27, 23, 19, 18} ;

static ValueStore converterValues
        [SIO_SIGNAL_CONVERTER_INST_COUNT]
        [SIO_CONTINUOUS_INPUT_POINT_INST_COUNT] = {
    [SIO_SIGNAL_CONVERTER_CVT1_INST_ID] = {
        [SIO_CONTINUOUS_INPUT_POINT_IOP1_INST_ID] = {
            .valueIndex = 0,
            .numValues = COUNTOF(inj1PresValues),
            .values = inj1PresValues
        },
        [SIO_CONTINUOUS_INPUT_POINT_IOP2_INST_ID] = {
            .valueIndex = 0,
            .numValues = COUNTOF(inj2PresValues),
            .values = inj2PresValues
        },
        [SIO_CONTINUOUS_INPUT_POINT_IOP3_INST_ID] = {
            .valueIndex = 0,
            .numValues = COUNTOF(inj2PresValues),
            .values = inj3PresValues
        },
    },
} ;
sio_Point_Value
eop_sio_DEVICE_Read_converted_value(
    sio_Converter_ID converter,
    sio_Point_ID point)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain sio eop DEVICE_Read_converted_value "
            "parameters {converter %" PRIu8 " point %" PRIu8 "}",
            converter, point) ;
#       endif /* TACK */

    assert(converter <= SIO_SIGNAL_CONVERTER_INST_COUNT) ;
    assert(point < SIO_IO_POINT_INST_COUNT) ;

    /*
     * Offset the point id to reorg to the beginning of Continuous Input
     * Point numbering.
     */
    sio_Point_ID cip = point - SIO_IO_POINT_IOP1_INST_ID ;

    return vs_nextValue(&converterValues[converter][cip]) ;
}
static sio_Point_Value m1LockoutValues[] = {0, 1} ;
static sio_Point_Value m2LockoutValues[] = {0, 1} ;
static sio_Point_Value m3LockoutValues[] = {0, 1} ;
static sio_Point_Value rsv1LevelValues[] = {1, 0} ;
static sio_Point_Value rsv2LevelValues[] = {1, 0} ;

static ValueStore registerValues[SIO_IO_POINT_INST_COUNT] = {
    [SIO_IO_POINT_IOP7_INST_ID] = {
        .valueIndex = 0,
        .numValues = COUNTOF(m1LockoutValues),
        .values = m1LockoutValues
    },
    [SIO_IO_POINT_IOP8_INST_ID] = {
        .valueIndex = 0,
        .numValues = COUNTOF(m2LockoutValues),
        .values = m2LockoutValues
    },
    [SIO_IO_POINT_IOP9_INST_ID] = {
        .valueIndex = 0,
        .numValues = COUNTOF(m3LockoutValues),
        .values = m3LockoutValues
    },
    [SIO_IO_POINT_IOP10_INST_ID] = {
        .valueIndex = 0,
        .numValues = COUNTOF(rsv1LevelValues),
        .values = rsv1LevelValues
    },
    [SIO_IO_POINT_IOP11_INST_ID] = {
        .valueIndex = 0,
        .numValues = COUNTOF(rsv2LevelValues),
        .values = rsv2LevelValues
    },
} ;
sio_Point_Value
eop_sio_DEVICE_Read_reg(
    sio_Point_ID pid)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain sio eop DEVICE_Read_reg "
            "parameters {pid %" PRIu8 "}", pid) ;
#       endif /* TACK */

    assert(pid < SIO_IO_POINT_INST_COUNT) ;

    return vs_nextValue(&registerValues[pid]) ;
}
