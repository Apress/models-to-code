/*
 * DO NOT EDIT THIS FILE!
 * THIS FILE IS GENERATED FROM THE SOURCE OF A LITERATE PROGRAM.
 * YOU MUST EDIT THE ORIGINAL SOURCE TO MODIFY THIS FILE.
 **++
 * Copyright 2017 by Leon Starr, Andrew Mangogna and Stephen Mellor
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Project:
 *   Models to Code Book
 *
 * Module:
 *   Lubrication / SIO domain bridge
 *   
 **--
*/

#include <stdbool.h>
#include <inttypes.h>
#include <stddef.h>
#include <assert.h>
#include "pycca_portal.h"
#include "lube.h"
#include "sio.h"
#ifdef TACK
#   include "harness.h"
#endif /* TACK */

#ifndef COUNTOF
#define COUNTOF(a)  (sizeof(a) / sizeof(a[0]))
#endif /* COUNTOF */

typedef struct {
    InstId_t fromInst ;
    InstId_t toInst ;
} BridgeIDMap ;
static sio_Point_ID const injToPointMap[LUBE_INJECTOR_INST_COUNT] = {
    [LUBE_INJECTOR_IN1_INST_ID] = SIO_IO_POINT_IOP1_INST_ID,
    [LUBE_INJECTOR_IN2_INST_ID] = SIO_IO_POINT_IOP2_INST_ID,
    [LUBE_INJECTOR_IN3_INST_ID] = SIO_IO_POINT_IOP3_INST_ID,
} ; // <1>
static sio_Point_ID const presToConvGrpMap[LUBE_INJECTOR_INST_COUNT] = {
    [LUBE_INJECTOR_IN1_INST_ID] = SIO_CONVERSION_GROUP_INJ1_CG_INST_ID,
    [LUBE_INJECTOR_IN2_INST_ID] = SIO_CONVERSION_GROUP_INJ2_CG_INST_ID,
    [LUBE_INJECTOR_IN3_INST_ID] = SIO_CONVERSION_GROUP_INJ3_CG_INST_ID,
} ;
static BridgeIDMap const presToInjMap[LUBE_INJECTOR_INST_COUNT] = {
    {
        .fromInst = SIO_IO_POINT_IOP1_INST_ID,
        .toInst = LUBE_INJECTOR_IN1_INST_ID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP2_INST_ID,
        .toInst = LUBE_INJECTOR_IN2_INST_ID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP3_INST_ID,
        .toInst = LUBE_INJECTOR_IN3_INST_ID,
    },
} ;
static BridgeIDMap const
    sigPtToLubeInstMap[LUBE_MACHINERY_INST_COUNT + LUBE_RESERVOIR_INST_COUNT] = {
    {
        .fromInst = SIO_IO_POINT_IOP7_INST_ID,
        .toInst = LUBE_MACHINERY_M1_INST_ID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP8_INST_ID,
        .toInst = LUBE_MACHINERY_M2_INST_ID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP9_INST_ID,
        .toInst = LUBE_MACHINERY_M3_INST_ID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP10_INST_ID,
        .toInst = LUBE_RESERVOIR_RES1_INST_ID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP11_INST_ID,
        .toInst = LUBE_RESERVOIR_RES2_INST_ID,
    },
} ;
static BridgeIDMap const *
mapIOPoint(
    BridgeIDMap const *mapping,
    int numMappings,
    InstId_t from)
{
    for ( ; numMappings > 0 ; numMappings--, mapping++) {
        if (mapping->fromInst == from) {
            return mapping ;
        }
    }

    return NULL ;
}
static void
signalInjector(
    InstId_t injectorId,
    EventCode event)
{
    assert(injectorId < LUBE_INJECTOR_INST_COUNT) ;

    int pcode = pycca_generate_event(&lube_portal,
        LUBE_INJECTOR_CLASS_ID,
        injectorId,
        NormalEvent,
        event,
        NULL) ;

    assert(pcode == 0) ;
    (void)pcode ;
}

static void
controlInjector(
    InstId_t injectorId,
    bool starting)
{
    assert(injectorId < LUBE_INJECTOR_INST_COUNT) ;

    sio_Write_point(injToPointMap[injectorId], starting ? 1 : 0) ; // <1>
}
void
eop_lube_SIO_Inject(
    InstId_t injectorId)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain lube eop SIO_Inject "
        "parameters {injectorId %" PRIu8 "}", injectorId) ;     // <1>
#       endif /* TACK */

    controlInjector(injectorId, true) ;
}
void
eop_lube_SIO_Stop_injecting(
    InstId_t injectorId)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain lube eop SIO_Stop_injecting "
        "parameters {injectorId %" PRIu8 "}", injectorId) ;
#       endif /* TACK */

    controlInjector(injectorId, false) ;
}
static void
signalConversionGroup(
    InstId_t injectorId,
    EventCode event)
{
    assert(injectorId < LUBE_INJECTOR_INST_COUNT) ;

    int pcode = pycca_generate_event(&sio_portal,
        SIO_CONVERSION_GROUP_CLASS_ID,
        presToConvGrpMap[injectorId],
        NormalEvent,
        event,
        NULL) ;

    assert(pcode == 0) ;
    (void)pcode ;                                   // <1>
}
void
eop_lube_SIO_Start_monitoring(
    InstId_t injectorId)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain lube eop SIO_Start_monitoring "
        "parameters {injectorId %" PRIu8 "}", injectorId) ;
#       endif /* TACK */

    signalConversionGroup(injectorId, SIO_CONVERSION_GROUP_SAMPLE_EVENT_ID) ;
}
void
eop_lube_SIO_Stop_monitoring(
    InstId_t injectorId)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain lube eop SIO_Stop_monitoring "
        "parameters {injectorId %" PRIu8 "}", injectorId) ;
#       endif /* TACK */

    signalConversionGroup(injectorId, SIO_CONVERSION_GROUP_STOP_EVENT_ID) ;
}
void
eop_sio_NOTIFY_New_point_value(
    sio_Point_ID point,
    sio_Point_Value value)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain sio eop NOTIFY_New_point_value "
        "parameters {point %" PRIu8 " value %" PRIi32 "}", point, value) ;
#       endif /* TACK */

    assert(point < SIO_IO_POINT_INST_COUNT) ;

    BridgeIDMap const * pointMap = mapIOPoint(presToInjMap, COUNTOF(presToInjMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    int pcode = pycca_update_attr(&lube_portal,
        LUBE_INJECTOR_CLASS_ID,
        pointMap->toInst,
        LUBE_INJECTOR_PRESSURE_ATTR_ID,
        &value,
        sizeof(value)) ;

    assert(pcode > 0) ;
    (void)pcode ;
}
void
eop_sio_NOTIFY_In_range(
    sio_Point_ID point,
    sio_Threshold_ID threshold)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain sio eop NOTIFY_In_range "
        "parameters {point %" PRIu8 " threshold %" PRIu8 "}", point, threshold) ;
#       endif /* TACK */

    assert(point < SIO_IO_POINT_INST_COUNT) ;
    assert(threshold < SIO_POINT_THRESHOLD_INST_COUNT) ;

    BridgeIDMap const *pointMap = mapIOPoint(presToInjMap, COUNTOF(presToInjMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    switch (threshold) {
    case SIO_POINT_THRESHOLD_IX77B_ABOVE_INJ_INST_ID:// fall through
    case SIO_POINT_THRESHOLD_IHN4_ABOVE_INJ_INST_ID:
        signalInjector(pointMap->toInst,
            LUBE_INJECTOR_BELOW_INJECT_PRESSURE_EVENT_ID) ;
        break ;

    /*
     * N.B. no default case.
     * Unexpected Range Limitation instances are silently ignored.
     */
    }
}
void
eop_sio_NOTIFY_Out_of_range(
    sio_Point_ID point,
    sio_Threshold_ID threshold)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain sio eop NOTIFY_Out_of_range "
        "parameters {point %" PRIu8 " threshold %" PRIu8 "}", point, threshold) ;
#       endif /* TACK */

    assert(point < SIO_IO_POINT_INST_COUNT) ;
    assert(threshold < SIO_POINT_THRESHOLD_INST_COUNT) ;

    BridgeIDMap const *pointMap = mapIOPoint(presToInjMap, COUNTOF(presToInjMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    switch (threshold) {
    case SIO_POINT_THRESHOLD_IX77B_ABOVE_INJ_INST_ID:// fall through
    case SIO_POINT_THRESHOLD_IHN4_ABOVE_INJ_INST_ID:
        signalInjector(pointMap->toInst,
                LUBE_INJECTOR_ABOVE_INJECT_PRESSURE_EVENT_ID) ;
        break ;

    case SIO_POINT_THRESHOLD_IX77B_ABOVE_DISP_INST_ID:// fall through
    case SIO_POINT_THRESHOLD_IHN4_ABOVE_DISP_INST_ID:
        signalInjector(pointMap->toInst,
                LUBE_INJECTOR_ABOVE_DISSIPATION_PRESSURE_EVENT_ID) ;
        break ;

    case SIO_POINT_THRESHOLD_IX77B_MAX_PRES_INST_ID:// fall through
    case SIO_POINT_THRESHOLD_IHN4_MAX_PRES_INST_ID:
        lube_Injector_max_pressure(pointMap->toInst) ;      // <1>
        break ;

    /*
     * N.B. no default case.
     * Unexpected Range Limitation instances are silently ignored.
     */
    }
}
void
eop_sio_NOTIFY_Signal_point(
    sio_Point_ID point,
    bool isActive)
{
#       ifdef TACK
    harness_stub_printf("stub", "domain sio eop NOTIFY_Signal_point "
        "parameters {point %" PRIu8 " isActive %" PRIu8 "}", point, isActive) ;
#       endif /* TACK */

    assert(point < SIO_IO_POINT_INST_COUNT) ;

    BridgeIDMap const * pointMap = mapIOPoint(sigPtToLubeInstMap,
            COUNTOF(sigPtToLubeInstMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    switch (point) {
    case SIO_IO_POINT_IOP7_INST_ID: // fall through
    case SIO_IO_POINT_IOP8_INST_ID: // fall through
    case SIO_IO_POINT_IOP9_INST_ID: {
        void (*lubeOp)(InstId_t) = isActive ?
                lube_Lock_Machinery : lube_Unlock_Machinery ;
        lubeOp(pointMap->toInst) ;
    }
        break ;

    case SIO_IO_POINT_IOP10_INST_ID: // fall through
    case SIO_IO_POINT_IOP11_INST_ID: {
        EventCode levelEvent = isActive ?
                LUBE_RESERVOIR_NORMAL_LUBE_LEVEL_EVENT_ID :
                LUBE_RESERVOIR_LOW_LUBE_LEVEL_EVENT_ID ;
        int pcode = pycca_generate_event(&lube_portal,
            LUBE_RESERVOIR_CLASS_ID,
            pointMap->toInst,
            NormalEvent,
            levelEvent,
            NULL) ;
        assert(pcode == 0) ;
        (void)pcode ;
    }
        break ;
    /*
     * N.B. no default case.
     */
    }
}
